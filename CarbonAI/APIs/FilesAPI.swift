//
// FilesAPI.swift
//
// Generated by Konfig
// https://konfigthis.com
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

open class FilesAPI {

    weak var client: CarbonAIClient?

    public init(client: CarbonAIClient) {
        self.client = client
    }

    /**
     Create File Tags
     
     - parameter organizationUserFileTagCreate: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func createUserFileTagsSync(organizationUserFileTagCreate: OrganizationUserFileTagCreate, apiResponseQueue: DispatchQueue = CarbonAIAPI.apiResponseQueue, completion: @escaping ((_ data: UserFile?, _ error: Error?) -> Void)) -> RequestTask {
        return createUserFileTagsWithRequestBuilder(organizationUserFileTagCreate: organizationUserFileTagCreate).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Create File Tags
     
     - parameter organizationUserFileTagCreate: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func createUserFileTagsAsyncMappedParams(organizationUserFileTagCreate: OrganizationUserFileTagCreate) async throws -> UserFile {
        return try await withCheckedThrowingContinuation { continuation in
            createUserFileTagsWithRequestBuilder(organizationUserFileTagCreate: organizationUserFileTagCreate).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Create File Tags
     
     - parameter organizationUserFileTagCreate: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func createUserFileTags(
        tags: [String: Tags1],
        organizationUserFileId: Int
    ) async throws -> UserFile {
        let organizationUserFileTagCreate = OrganizationUserFileTagCreate(
            tags: tags,
            organizationUserFileId: organizationUserFileId
        )
        return try await withCheckedThrowingContinuation { continuation in
            createUserFileTagsWithRequestBuilder(organizationUserFileTagCreate: organizationUserFileTagCreate).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Create File Tags
     
     - parameter organizationUserFileTagCreate: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func createUserFileTags(
        tags: [String: Tags1],
        organizationUserFileId: Int
    ) async throws -> UserFile {
        let organizationUserFileTagCreate = OrganizationUserFileTagCreate(
            tags: tags,
            organizationUserFileId: organizationUserFileId
        )
        return try await withCheckedThrowingContinuation { continuation in
            createUserFileTagsWithRequestBuilder(organizationUserFileTagCreate: organizationUserFileTagCreate).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Create File Tags
     - POST /create_user_file_tags
     - A tag is a key-value pair that can be added to a file. This pair can then be used for searches (e.g. embedding searches) in order to narrow down the scope of the search. A file can have any number of tags. The following are reserved keys that cannot be used: - db_embedding_id - organization_id - user_id - organization_user_file_id  Carbon currently supports two data types for tag values - `string` and `list<string>`. Keys can only be `string`. If values other than `string` and `list<string>` are used, they're automatically converted to strings (e.g. 4 will become \"4\").
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter organizationUserFileTagCreate: (body)  
     - returns: RequestBuilder<UserFile> A tag is a key-value pair that can be added to a file. This pair can then be used for searches (e.g. embedding searches) in order to narrow down the scope of the search. A file can have any number of tags. The following are reserved keys that cannot be used: - db_embedding_id - organization_id - user_id - organization_user_file_id  Carbon currently supports two data types for tag values - &#x60;string&#x60; and &#x60;list&lt;string&gt;&#x60;. Keys can only be &#x60;string&#x60;. If values other than &#x60;string&#x60; and &#x60;list&lt;string&gt;&#x60; are used, they&#39;re automatically converted to strings (e.g. 4 will become \&quot;4\&quot;).
     */
    open class func createUserFileTagsWithRequestBuilder(
            organizationUserFileTagCreate: OrganizationUserFileTagCreate
    ) -> RequestBuilder<UserFile> {
        let basePath = CarbonAIAPI.basePath;
        let localVariablePath = "/create_user_file_tags"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: organizationUserFileTagCreate)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAIAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /create_user_file_tags")
    }

    /**
     Create File Tags
     - POST /create_user_file_tags
     - A tag is a key-value pair that can be added to a file. This pair can then be used for searches (e.g. embedding searches) in order to narrow down the scope of the search. A file can have any number of tags. The following are reserved keys that cannot be used: - db_embedding_id - organization_id - user_id - organization_user_file_id  Carbon currently supports two data types for tag values - `string` and `list<string>`. Keys can only be `string`. If values other than `string` and `list<string>` are used, they're automatically converted to strings (e.g. 4 will become \"4\").
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter organizationUserFileTagCreate: (body)  
     - returns: RequestBuilder<UserFile> A tag is a key-value pair that can be added to a file. This pair can then be used for searches (e.g. embedding searches) in order to narrow down the scope of the search. A file can have any number of tags. The following are reserved keys that cannot be used: - db_embedding_id - organization_id - user_id - organization_user_file_id  Carbon currently supports two data types for tag values - &#x60;string&#x60; and &#x60;list&lt;string&gt;&#x60;. Keys can only be &#x60;string&#x60;. If values other than &#x60;string&#x60; and &#x60;list&lt;string&gt;&#x60; are used, they&#39;re automatically converted to strings (e.g. 4 will become \&quot;4\&quot;).
     */
    open func createUserFileTagsWithRequestBuilder(
            organizationUserFileTagCreate: OrganizationUserFileTagCreate
    ) -> RequestBuilder<UserFile> {
        let basePath = self.client!.basePath;
        let localVariablePath = "/create_user_file_tags"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: organizationUserFileTagCreate)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client!.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /create_user_file_tags")
    }


    /**
     Delete File Endpoint
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @discardableResult
    open class func deleteSync(fileId: Int, apiResponseQueue: DispatchQueue = CarbonAIAPI.apiResponseQueue, completion: @escaping ((_ data: GenericSuccessResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return deleteWithRequestBuilder(fileId: fileId).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Delete File Endpoint
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func deleteAsyncMappedParams(fileId: Int) async throws -> GenericSuccessResponse {
        return try await withCheckedThrowingContinuation { continuation in
            deleteWithRequestBuilder(fileId: fileId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Delete File Endpoint
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func delete(
        fileId: Int
    ) async throws -> GenericSuccessResponse {
        return try await withCheckedThrowingContinuation { continuation in
            deleteWithRequestBuilder(fileId: fileId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Delete File Endpoint
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func delete(
        fileId: Int
    ) async throws -> GenericSuccessResponse {
        return try await withCheckedThrowingContinuation { continuation in
            deleteWithRequestBuilder(fileId: fileId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Delete File Endpoint
     - DELETE /deletefile/{file_id}
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter fileId: (path)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open class func deleteWithRequestBuilder(
            fileId: Int
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = CarbonAIAPI.basePath;
        var localVariablePath = "/deletefile/{file_id}"
        let fileIdPreEscape = "\(APIHelper.mapValueToPathItem(fileId))"
        let fileIdPostEscape = fileIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{file_id}", with: fileIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAIAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "DELETE", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to DELETE /deletefile/{file_id}")
    }

    /**
     Delete File Endpoint
     - DELETE /deletefile/{file_id}
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter fileId: (path)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open func deleteWithRequestBuilder(
            fileId: Int
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = self.client!.basePath;
        var localVariablePath = "/deletefile/{file_id}"
        let fileIdPreEscape = "\(APIHelper.mapValueToPathItem(fileId))"
        let fileIdPostEscape = fileIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{file_id}", with: fileIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client!.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "DELETE", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to DELETE /deletefile/{file_id}")
    }


    /**
     Delete File Tags
     
     - parameter organizationUserFileTagsRemove: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func deleteFileTagsSync(organizationUserFileTagsRemove: OrganizationUserFileTagsRemove, apiResponseQueue: DispatchQueue = CarbonAIAPI.apiResponseQueue, completion: @escaping ((_ data: UserFile?, _ error: Error?) -> Void)) -> RequestTask {
        return deleteFileTagsWithRequestBuilder(organizationUserFileTagsRemove: organizationUserFileTagsRemove).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Delete File Tags
     
     - parameter organizationUserFileTagsRemove: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func deleteFileTagsAsyncMappedParams(organizationUserFileTagsRemove: OrganizationUserFileTagsRemove) async throws -> UserFile {
        return try await withCheckedThrowingContinuation { continuation in
            deleteFileTagsWithRequestBuilder(organizationUserFileTagsRemove: organizationUserFileTagsRemove).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Delete File Tags
     
     - parameter organizationUserFileTagsRemove: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func deleteFileTags(
        tags: [String],
        organizationUserFileId: Int
    ) async throws -> UserFile {
        let organizationUserFileTagsRemove = OrganizationUserFileTagsRemove(
            tags: tags,
            organizationUserFileId: organizationUserFileId
        )
        return try await withCheckedThrowingContinuation { continuation in
            deleteFileTagsWithRequestBuilder(organizationUserFileTagsRemove: organizationUserFileTagsRemove).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Delete File Tags
     
     - parameter organizationUserFileTagsRemove: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func deleteFileTags(
        tags: [String],
        organizationUserFileId: Int
    ) async throws -> UserFile {
        let organizationUserFileTagsRemove = OrganizationUserFileTagsRemove(
            tags: tags,
            organizationUserFileId: organizationUserFileId
        )
        return try await withCheckedThrowingContinuation { continuation in
            deleteFileTagsWithRequestBuilder(organizationUserFileTagsRemove: organizationUserFileTagsRemove).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Delete File Tags
     - POST /delete_user_file_tags
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter organizationUserFileTagsRemove: (body)  
     - returns: RequestBuilder<UserFile> 
     */
    open class func deleteFileTagsWithRequestBuilder(
            organizationUserFileTagsRemove: OrganizationUserFileTagsRemove
    ) -> RequestBuilder<UserFile> {
        let basePath = CarbonAIAPI.basePath;
        let localVariablePath = "/delete_user_file_tags"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: organizationUserFileTagsRemove)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAIAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /delete_user_file_tags")
    }

    /**
     Delete File Tags
     - POST /delete_user_file_tags
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter organizationUserFileTagsRemove: (body)  
     - returns: RequestBuilder<UserFile> 
     */
    open func deleteFileTagsWithRequestBuilder(
            organizationUserFileTagsRemove: OrganizationUserFileTagsRemove
    ) -> RequestBuilder<UserFile> {
        let basePath = self.client!.basePath;
        let localVariablePath = "/delete_user_file_tags"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: organizationUserFileTagsRemove)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client!.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /delete_user_file_tags")
    }


    /**
     Delete Files Endpoint
     
     - parameter deleteFilesQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @discardableResult
    open class func deleteManySync(deleteFilesQueryInput: DeleteFilesQueryInput, apiResponseQueue: DispatchQueue = CarbonAIAPI.apiResponseQueue, completion: @escaping ((_ data: GenericSuccessResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return deleteManyWithRequestBuilder(deleteFilesQueryInput: deleteFilesQueryInput).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Delete Files Endpoint
     
     - parameter deleteFilesQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func deleteManyAsyncMappedParams(deleteFilesQueryInput: DeleteFilesQueryInput) async throws -> GenericSuccessResponse {
        return try await withCheckedThrowingContinuation { continuation in
            deleteManyWithRequestBuilder(deleteFilesQueryInput: deleteFilesQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Delete Files Endpoint
     
     - parameter deleteFilesQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func deleteMany(
        fileIds: [Int]? = nil, 
        syncStatuses: [ExternalFileSyncStatuses]? = nil, 
        deleteNonSyncedOnly: Bool? = nil, 
        sendWebhook: Bool? = nil, 
        deleteChildFiles: Bool? = nil
    ) async throws -> GenericSuccessResponse {
        let deleteFilesQueryInput = DeleteFilesQueryInput(
            fileIds: fileIds,
            syncStatuses: syncStatuses,
            deleteNonSyncedOnly: deleteNonSyncedOnly,
            sendWebhook: sendWebhook,
            deleteChildFiles: deleteChildFiles
        )
        return try await withCheckedThrowingContinuation { continuation in
            deleteManyWithRequestBuilder(deleteFilesQueryInput: deleteFilesQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Delete Files Endpoint
     
     - parameter deleteFilesQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func deleteMany(
        fileIds: [Int]? = nil, 
        syncStatuses: [ExternalFileSyncStatuses]? = nil, 
        deleteNonSyncedOnly: Bool? = nil, 
        sendWebhook: Bool? = nil, 
        deleteChildFiles: Bool? = nil
    ) async throws -> GenericSuccessResponse {
        let deleteFilesQueryInput = DeleteFilesQueryInput(
            fileIds: fileIds,
            syncStatuses: syncStatuses,
            deleteNonSyncedOnly: deleteNonSyncedOnly,
            sendWebhook: sendWebhook,
            deleteChildFiles: deleteChildFiles
        )
        return try await withCheckedThrowingContinuation { continuation in
            deleteManyWithRequestBuilder(deleteFilesQueryInput: deleteFilesQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Delete Files Endpoint
     - POST /delete_files
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter deleteFilesQueryInput: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open class func deleteManyWithRequestBuilder(
            deleteFilesQueryInput: DeleteFilesQueryInput
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = CarbonAIAPI.basePath;
        let localVariablePath = "/delete_files"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: deleteFilesQueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAIAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /delete_files")
    }

    /**
     Delete Files Endpoint
     - POST /delete_files
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter deleteFilesQueryInput: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open func deleteManyWithRequestBuilder(
            deleteFilesQueryInput: DeleteFilesQueryInput
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = self.client!.basePath;
        let localVariablePath = "/delete_files"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: deleteFilesQueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client!.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /delete_files")
    }


    /**
     Delete Files V2 Endpoint
     
     - parameter deleteFilesV2QueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func deleteV2Sync(deleteFilesV2QueryInput: DeleteFilesV2QueryInput, apiResponseQueue: DispatchQueue = CarbonAIAPI.apiResponseQueue, completion: @escaping ((_ data: GenericSuccessResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return deleteV2WithRequestBuilder(deleteFilesV2QueryInput: deleteFilesV2QueryInput).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Delete Files V2 Endpoint
     
     - parameter deleteFilesV2QueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func deleteV2AsyncMappedParams(deleteFilesV2QueryInput: DeleteFilesV2QueryInput) async throws -> GenericSuccessResponse {
        return try await withCheckedThrowingContinuation { continuation in
            deleteV2WithRequestBuilder(deleteFilesV2QueryInput: deleteFilesV2QueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Delete Files V2 Endpoint
     
     - parameter deleteFilesV2QueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func deleteV2(
        filters: OrganizationUserFilesToSyncFilters? = nil, 
        sendWebhook: Bool? = nil, 
        preserveFileRecord: Bool? = nil
    ) async throws -> GenericSuccessResponse {
        let deleteFilesV2QueryInput = DeleteFilesV2QueryInput(
            filters: filters,
            sendWebhook: sendWebhook,
            preserveFileRecord: preserveFileRecord
        )
        return try await withCheckedThrowingContinuation { continuation in
            deleteV2WithRequestBuilder(deleteFilesV2QueryInput: deleteFilesV2QueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Delete Files V2 Endpoint
     
     - parameter deleteFilesV2QueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func deleteV2(
        filters: OrganizationUserFilesToSyncFilters? = nil, 
        sendWebhook: Bool? = nil, 
        preserveFileRecord: Bool? = nil
    ) async throws -> GenericSuccessResponse {
        let deleteFilesV2QueryInput = DeleteFilesV2QueryInput(
            filters: filters,
            sendWebhook: sendWebhook,
            preserveFileRecord: preserveFileRecord
        )
        return try await withCheckedThrowingContinuation { continuation in
            deleteV2WithRequestBuilder(deleteFilesV2QueryInput: deleteFilesV2QueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Delete Files V2 Endpoint
     - POST /delete_files_v2
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter deleteFilesV2QueryInput: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    open class func deleteV2WithRequestBuilder(
            deleteFilesV2QueryInput: DeleteFilesV2QueryInput
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = CarbonAIAPI.basePath;
        let localVariablePath = "/delete_files_v2"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: deleteFilesV2QueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAIAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /delete_files_v2")
    }

    /**
     Delete Files V2 Endpoint
     - POST /delete_files_v2
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter deleteFilesV2QueryInput: (body)  
     - returns: RequestBuilder<GenericSuccessResponse> 
     */
    open func deleteV2WithRequestBuilder(
            deleteFilesV2QueryInput: DeleteFilesV2QueryInput
    ) -> RequestBuilder<GenericSuccessResponse> {
        let basePath = self.client!.basePath;
        let localVariablePath = "/delete_files_v2"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: deleteFilesV2QueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client!.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<GenericSuccessResponse>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /delete_files_v2")
    }


    /**
     Parsed File
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @discardableResult
    open class func getParsedFileSync(fileId: Int, apiResponseQueue: DispatchQueue = CarbonAIAPI.apiResponseQueue, completion: @escaping ((_ data: PresignedURLResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return getParsedFileWithRequestBuilder(fileId: fileId).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Parsed File
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func getParsedFileAsyncMappedParams(fileId: Int) async throws -> PresignedURLResponse {
        return try await withCheckedThrowingContinuation { continuation in
            getParsedFileWithRequestBuilder(fileId: fileId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Parsed File
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func getParsedFile(
        fileId: Int
    ) async throws -> PresignedURLResponse {
        return try await withCheckedThrowingContinuation { continuation in
            getParsedFileWithRequestBuilder(fileId: fileId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Parsed File
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func getParsedFile(
        fileId: Int
    ) async throws -> PresignedURLResponse {
        return try await withCheckedThrowingContinuation { continuation in
            getParsedFileWithRequestBuilder(fileId: fileId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Parsed File
     - GET /parsed_file/{file_id}
     - This route is deprecated. Use `/user_files_v2` instead.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter fileId: (path)  
     - returns: RequestBuilder<PresignedURLResponse> This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open class func getParsedFileWithRequestBuilder(
            fileId: Int
    ) -> RequestBuilder<PresignedURLResponse> {
        let basePath = CarbonAIAPI.basePath;
        var localVariablePath = "/parsed_file/{file_id}"
        let fileIdPreEscape = "\(APIHelper.mapValueToPathItem(fileId))"
        let fileIdPostEscape = fileIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{file_id}", with: fileIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAIAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<PresignedURLResponse>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /parsed_file/{file_id}")
    }

    /**
     Parsed File
     - GET /parsed_file/{file_id}
     - This route is deprecated. Use `/user_files_v2` instead.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter fileId: (path)  
     - returns: RequestBuilder<PresignedURLResponse> This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open func getParsedFileWithRequestBuilder(
            fileId: Int
    ) -> RequestBuilder<PresignedURLResponse> {
        let basePath = self.client!.basePath;
        var localVariablePath = "/parsed_file/{file_id}"
        let fileIdPreEscape = "\(APIHelper.mapValueToPathItem(fileId))"
        let fileIdPostEscape = fileIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{file_id}", with: fileIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client!.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<PresignedURLResponse>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /parsed_file/{file_id}")
    }


    /**
     Raw File
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @discardableResult
    open class func getRawFileSync(fileId: Int, apiResponseQueue: DispatchQueue = CarbonAIAPI.apiResponseQueue, completion: @escaping ((_ data: PresignedURLResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return getRawFileWithRequestBuilder(fileId: fileId).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Raw File
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func getRawFileAsyncMappedParams(fileId: Int) async throws -> PresignedURLResponse {
        return try await withCheckedThrowingContinuation { continuation in
            getRawFileWithRequestBuilder(fileId: fileId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Raw File
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func getRawFile(
        fileId: Int
    ) async throws -> PresignedURLResponse {
        return try await withCheckedThrowingContinuation { continuation in
            getRawFileWithRequestBuilder(fileId: fileId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Raw File
     
     - parameter fileId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func getRawFile(
        fileId: Int
    ) async throws -> PresignedURLResponse {
        return try await withCheckedThrowingContinuation { continuation in
            getRawFileWithRequestBuilder(fileId: fileId).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Raw File
     - GET /raw_file/{file_id}
     - This route is deprecated. Use `/user_files_v2` instead.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter fileId: (path)  
     - returns: RequestBuilder<PresignedURLResponse> This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open class func getRawFileWithRequestBuilder(
            fileId: Int
    ) -> RequestBuilder<PresignedURLResponse> {
        let basePath = CarbonAIAPI.basePath;
        var localVariablePath = "/raw_file/{file_id}"
        let fileIdPreEscape = "\(APIHelper.mapValueToPathItem(fileId))"
        let fileIdPostEscape = fileIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{file_id}", with: fileIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAIAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<PresignedURLResponse>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /raw_file/{file_id}")
    }

    /**
     Raw File
     - GET /raw_file/{file_id}
     - This route is deprecated. Use `/user_files_v2` instead.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter fileId: (path)  
     - returns: RequestBuilder<PresignedURLResponse> This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open func getRawFileWithRequestBuilder(
            fileId: Int
    ) -> RequestBuilder<PresignedURLResponse> {
        let basePath = self.client!.basePath;
        var localVariablePath = "/raw_file/{file_id}"
        let fileIdPreEscape = "\(APIHelper.mapValueToPathItem(fileId))"
        let fileIdPostEscape = fileIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{file_id}", with: fileIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client!.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<PresignedURLResponse>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "GET", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to GET /raw_file/{file_id}")
    }


    /**
     Modify Cold Storage Parameters
     
     - parameter modifyColdStorageParametersQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func modifyColdStorageParametersSync(modifyColdStorageParametersQueryInput: ModifyColdStorageParametersQueryInput, apiResponseQueue: DispatchQueue = CarbonAIAPI.apiResponseQueue, completion: @escaping ((_ data: Bool?, _ error: Error?) -> Void)) -> RequestTask {
        return modifyColdStorageParametersWithRequestBuilder(modifyColdStorageParametersQueryInput: modifyColdStorageParametersQueryInput).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Modify Cold Storage Parameters
     
     - parameter modifyColdStorageParametersQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func modifyColdStorageParametersAsyncMappedParams(modifyColdStorageParametersQueryInput: ModifyColdStorageParametersQueryInput) async throws -> Bool {
        return try await withCheckedThrowingContinuation { continuation in
            modifyColdStorageParametersWithRequestBuilder(modifyColdStorageParametersQueryInput: modifyColdStorageParametersQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Modify Cold Storage Parameters
     
     - parameter modifyColdStorageParametersQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func modifyColdStorageParameters(
        filters: OrganizationUserFilesToSyncFilters? = nil, 
        enableColdStorage: Bool? = nil, 
        hotStorageTimeToLive: Int? = nil
    ) async throws -> Bool {
        let modifyColdStorageParametersQueryInput = ModifyColdStorageParametersQueryInput(
            filters: filters,
            enableColdStorage: enableColdStorage,
            hotStorageTimeToLive: hotStorageTimeToLive
        )
        return try await withCheckedThrowingContinuation { continuation in
            modifyColdStorageParametersWithRequestBuilder(modifyColdStorageParametersQueryInput: modifyColdStorageParametersQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Modify Cold Storage Parameters
     
     - parameter modifyColdStorageParametersQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func modifyColdStorageParameters(
        filters: OrganizationUserFilesToSyncFilters? = nil, 
        enableColdStorage: Bool? = nil, 
        hotStorageTimeToLive: Int? = nil
    ) async throws -> Bool {
        let modifyColdStorageParametersQueryInput = ModifyColdStorageParametersQueryInput(
            filters: filters,
            enableColdStorage: enableColdStorage,
            hotStorageTimeToLive: hotStorageTimeToLive
        )
        return try await withCheckedThrowingContinuation { continuation in
            modifyColdStorageParametersWithRequestBuilder(modifyColdStorageParametersQueryInput: modifyColdStorageParametersQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Modify Cold Storage Parameters
     - POST /modify_cold_storage_parameters
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter modifyColdStorageParametersQueryInput: (body)  
     - returns: RequestBuilder<Bool> 
     */
    open class func modifyColdStorageParametersWithRequestBuilder(
            modifyColdStorageParametersQueryInput: ModifyColdStorageParametersQueryInput
    ) -> RequestBuilder<Bool> {
        let basePath = CarbonAIAPI.basePath;
        let localVariablePath = "/modify_cold_storage_parameters"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: modifyColdStorageParametersQueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAIAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<Bool>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /modify_cold_storage_parameters")
    }

    /**
     Modify Cold Storage Parameters
     - POST /modify_cold_storage_parameters
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter modifyColdStorageParametersQueryInput: (body)  
     - returns: RequestBuilder<Bool> 
     */
    open func modifyColdStorageParametersWithRequestBuilder(
            modifyColdStorageParametersQueryInput: ModifyColdStorageParametersQueryInput
    ) -> RequestBuilder<Bool> {
        let basePath = self.client!.basePath;
        let localVariablePath = "/modify_cold_storage_parameters"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: modifyColdStorageParametersQueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client!.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<Bool>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /modify_cold_storage_parameters")
    }


    /**
     Move To Hot Storage
     
     - parameter moveToHotStorageQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func moveToHotStorageSync(moveToHotStorageQueryInput: MoveToHotStorageQueryInput, apiResponseQueue: DispatchQueue = CarbonAIAPI.apiResponseQueue, completion: @escaping ((_ data: Bool?, _ error: Error?) -> Void)) -> RequestTask {
        return moveToHotStorageWithRequestBuilder(moveToHotStorageQueryInput: moveToHotStorageQueryInput).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Move To Hot Storage
     
     - parameter moveToHotStorageQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func moveToHotStorageAsyncMappedParams(moveToHotStorageQueryInput: MoveToHotStorageQueryInput) async throws -> Bool {
        return try await withCheckedThrowingContinuation { continuation in
            moveToHotStorageWithRequestBuilder(moveToHotStorageQueryInput: moveToHotStorageQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Move To Hot Storage
     
     - parameter moveToHotStorageQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func moveToHotStorage(
        filters: OrganizationUserFilesToSyncFilters? = nil
    ) async throws -> Bool {
        let moveToHotStorageQueryInput = MoveToHotStorageQueryInput(
            filters: filters
        )
        return try await withCheckedThrowingContinuation { continuation in
            moveToHotStorageWithRequestBuilder(moveToHotStorageQueryInput: moveToHotStorageQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Move To Hot Storage
     
     - parameter moveToHotStorageQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func moveToHotStorage(
        filters: OrganizationUserFilesToSyncFilters? = nil
    ) async throws -> Bool {
        let moveToHotStorageQueryInput = MoveToHotStorageQueryInput(
            filters: filters
        )
        return try await withCheckedThrowingContinuation { continuation in
            moveToHotStorageWithRequestBuilder(moveToHotStorageQueryInput: moveToHotStorageQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Move To Hot Storage
     - POST /move_to_hot_storage
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter moveToHotStorageQueryInput: (body)  
     - returns: RequestBuilder<Bool> 
     */
    open class func moveToHotStorageWithRequestBuilder(
            moveToHotStorageQueryInput: MoveToHotStorageQueryInput
    ) -> RequestBuilder<Bool> {
        let basePath = CarbonAIAPI.basePath;
        let localVariablePath = "/move_to_hot_storage"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: moveToHotStorageQueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAIAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<Bool>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /move_to_hot_storage")
    }

    /**
     Move To Hot Storage
     - POST /move_to_hot_storage
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter moveToHotStorageQueryInput: (body)  
     - returns: RequestBuilder<Bool> 
     */
    open func moveToHotStorageWithRequestBuilder(
            moveToHotStorageQueryInput: MoveToHotStorageQueryInput
    ) -> RequestBuilder<Bool> {
        let basePath = self.client!.basePath;
        let localVariablePath = "/move_to_hot_storage"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: moveToHotStorageQueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client!.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<Bool>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /move_to_hot_storage")
    }


    /**
     User Files V2
     
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func queryUserFilesSync(organizationUserFilesToSyncQueryInput: OrganizationUserFilesToSyncQueryInput, apiResponseQueue: DispatchQueue = CarbonAIAPI.apiResponseQueue, completion: @escaping ((_ data: UserFilesV2?, _ error: Error?) -> Void)) -> RequestTask {
        return queryUserFilesWithRequestBuilder(organizationUserFilesToSyncQueryInput: organizationUserFilesToSyncQueryInput).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     User Files V2
     
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func queryUserFilesAsyncMappedParams(organizationUserFilesToSyncQueryInput: OrganizationUserFilesToSyncQueryInput) async throws -> UserFilesV2 {
        return try await withCheckedThrowingContinuation { continuation in
            queryUserFilesWithRequestBuilder(organizationUserFilesToSyncQueryInput: organizationUserFilesToSyncQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     User Files V2
     
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func queryUserFiles(
        pagination: Pagination? = nil, 
        orderBy: OrganizationUserFilesToSyncOrderByTypes? = nil, 
        orderDir: OrderDir? = nil, 
        filters: OrganizationUserFilesToSyncFilters? = nil, 
        includeRawFile: Bool? = nil, 
        includeParsedTextFile: Bool? = nil, 
        includeAdditionalFiles: Bool? = nil
    ) async throws -> UserFilesV2 {
        let organizationUserFilesToSyncQueryInput = OrganizationUserFilesToSyncQueryInput(
            pagination: pagination,
            orderBy: orderBy,
            orderDir: orderDir,
            filters: filters,
            includeRawFile: includeRawFile,
            includeParsedTextFile: includeParsedTextFile,
            includeAdditionalFiles: includeAdditionalFiles
        )
        return try await withCheckedThrowingContinuation { continuation in
            queryUserFilesWithRequestBuilder(organizationUserFilesToSyncQueryInput: organizationUserFilesToSyncQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     User Files V2
     
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func queryUserFiles(
        pagination: Pagination? = nil, 
        orderBy: OrganizationUserFilesToSyncOrderByTypes? = nil, 
        orderDir: OrderDir? = nil, 
        filters: OrganizationUserFilesToSyncFilters? = nil, 
        includeRawFile: Bool? = nil, 
        includeParsedTextFile: Bool? = nil, 
        includeAdditionalFiles: Bool? = nil
    ) async throws -> UserFilesV2 {
        let organizationUserFilesToSyncQueryInput = OrganizationUserFilesToSyncQueryInput(
            pagination: pagination,
            orderBy: orderBy,
            orderDir: orderDir,
            filters: filters,
            includeRawFile: includeRawFile,
            includeParsedTextFile: includeParsedTextFile,
            includeAdditionalFiles: includeAdditionalFiles
        )
        return try await withCheckedThrowingContinuation { continuation in
            queryUserFilesWithRequestBuilder(organizationUserFilesToSyncQueryInput: organizationUserFilesToSyncQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     User Files V2
     - POST /user_files_v2
     - For pre-filtering documents, using `tags_v2` is preferred to using `tags` (which is now deprecated). If both `tags_v2` and `tags` are specified, `tags` is ignored. `tags_v2` enables building complex filters through the use of \"AND\", \"OR\", and negation logic. Take the below input as an example: ```json {     \"OR\": [         {             \"key\": \"subject\",             \"value\": \"holy-bible\",             \"negate\": false         },         {             \"key\": \"person-of-interest\",             \"value\": \"jesus christ\",             \"negate\": false         },         {             \"key\": \"genre\",             \"value\": \"religion\",             \"negate\": true         }         {             \"AND\": [                 {                     \"key\": \"subject\",                     \"value\": \"tao-te-ching\",                     \"negate\": false                 },                 {                     \"key\": \"author\",                     \"value\": \"lao-tzu\",                     \"negate\": false                 }             ]         }     ] } ``` In this case, files will be filtered such that: 1. \"subject\" = \"holy-bible\" OR 2. \"person-of-interest\" = \"jesus christ\" OR 3. \"genre\" != \"religion\" OR 4. \"subject\" = \"tao-te-ching\" AND \"author\" = \"lao-tzu\"  Note that the top level of the query must be either an \"OR\" or \"AND\" array. Currently, nesting is limited to 3. For tag blocks (those with \"key\", \"value\", and \"negate\" keys), the following typing rules apply: 1. \"key\" isn't optional and must be a `string` 2. \"value\" isn't optional and can be `any` or list[`any`] 3. \"negate\" is optional and must be `true` or `false`. If present and `true`, then the filter block is negated in the resulting query. It is `false` by default.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - returns: RequestBuilder<UserFilesV2> For pre-filtering documents, using &#x60;tags_v2&#x60; is preferred to using &#x60;tags&#x60; (which is now deprecated). If both &#x60;tags_v2&#x60; and &#x60;tags&#x60; are specified, &#x60;tags&#x60; is ignored. &#x60;tags_v2&#x60; enables building complex filters through the use of \&quot;AND\&quot;, \&quot;OR\&quot;, and negation logic. Take the below input as an example: &#x60;&#x60;&#x60;json {     \&quot;OR\&quot;: [         {             \&quot;key\&quot;: \&quot;subject\&quot;,             \&quot;value\&quot;: \&quot;holy-bible\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;person-of-interest\&quot;,             \&quot;value\&quot;: \&quot;jesus christ\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;genre\&quot;,             \&quot;value\&quot;: \&quot;religion\&quot;,             \&quot;negate\&quot;: true         }         {             \&quot;AND\&quot;: [                 {                     \&quot;key\&quot;: \&quot;subject\&quot;,                     \&quot;value\&quot;: \&quot;tao-te-ching\&quot;,                     \&quot;negate\&quot;: false                 },                 {                     \&quot;key\&quot;: \&quot;author\&quot;,                     \&quot;value\&quot;: \&quot;lao-tzu\&quot;,                     \&quot;negate\&quot;: false                 }             ]         }     ] } &#x60;&#x60;&#x60; In this case, files will be filtered such that: 1. \&quot;subject\&quot; &#x3D; \&quot;holy-bible\&quot; OR 2. \&quot;person-of-interest\&quot; &#x3D; \&quot;jesus christ\&quot; OR 3. \&quot;genre\&quot; !&#x3D; \&quot;religion\&quot; OR 4. \&quot;subject\&quot; &#x3D; \&quot;tao-te-ching\&quot; AND \&quot;author\&quot; &#x3D; \&quot;lao-tzu\&quot;  Note that the top level of the query must be either an \&quot;OR\&quot; or \&quot;AND\&quot; array. Currently, nesting is limited to 3. For tag blocks (those with \&quot;key\&quot;, \&quot;value\&quot;, and \&quot;negate\&quot; keys), the following typing rules apply: 1. \&quot;key\&quot; isn&#39;t optional and must be a &#x60;string&#x60; 2. \&quot;value\&quot; isn&#39;t optional and can be &#x60;any&#x60; or list[&#x60;any&#x60;] 3. \&quot;negate\&quot; is optional and must be &#x60;true&#x60; or &#x60;false&#x60;. If present and &#x60;true&#x60;, then the filter block is negated in the resulting query. It is &#x60;false&#x60; by default.
     */
    open class func queryUserFilesWithRequestBuilder(
            organizationUserFilesToSyncQueryInput: OrganizationUserFilesToSyncQueryInput
    ) -> RequestBuilder<UserFilesV2> {
        let basePath = CarbonAIAPI.basePath;
        let localVariablePath = "/user_files_v2"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: organizationUserFilesToSyncQueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAIAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFilesV2>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /user_files_v2")
    }

    /**
     User Files V2
     - POST /user_files_v2
     - For pre-filtering documents, using `tags_v2` is preferred to using `tags` (which is now deprecated). If both `tags_v2` and `tags` are specified, `tags` is ignored. `tags_v2` enables building complex filters through the use of \"AND\", \"OR\", and negation logic. Take the below input as an example: ```json {     \"OR\": [         {             \"key\": \"subject\",             \"value\": \"holy-bible\",             \"negate\": false         },         {             \"key\": \"person-of-interest\",             \"value\": \"jesus christ\",             \"negate\": false         },         {             \"key\": \"genre\",             \"value\": \"religion\",             \"negate\": true         }         {             \"AND\": [                 {                     \"key\": \"subject\",                     \"value\": \"tao-te-ching\",                     \"negate\": false                 },                 {                     \"key\": \"author\",                     \"value\": \"lao-tzu\",                     \"negate\": false                 }             ]         }     ] } ``` In this case, files will be filtered such that: 1. \"subject\" = \"holy-bible\" OR 2. \"person-of-interest\" = \"jesus christ\" OR 3. \"genre\" != \"religion\" OR 4. \"subject\" = \"tao-te-ching\" AND \"author\" = \"lao-tzu\"  Note that the top level of the query must be either an \"OR\" or \"AND\" array. Currently, nesting is limited to 3. For tag blocks (those with \"key\", \"value\", and \"negate\" keys), the following typing rules apply: 1. \"key\" isn't optional and must be a `string` 2. \"value\" isn't optional and can be `any` or list[`any`] 3. \"negate\" is optional and must be `true` or `false`. If present and `true`, then the filter block is negated in the resulting query. It is `false` by default.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - returns: RequestBuilder<UserFilesV2> For pre-filtering documents, using &#x60;tags_v2&#x60; is preferred to using &#x60;tags&#x60; (which is now deprecated). If both &#x60;tags_v2&#x60; and &#x60;tags&#x60; are specified, &#x60;tags&#x60; is ignored. &#x60;tags_v2&#x60; enables building complex filters through the use of \&quot;AND\&quot;, \&quot;OR\&quot;, and negation logic. Take the below input as an example: &#x60;&#x60;&#x60;json {     \&quot;OR\&quot;: [         {             \&quot;key\&quot;: \&quot;subject\&quot;,             \&quot;value\&quot;: \&quot;holy-bible\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;person-of-interest\&quot;,             \&quot;value\&quot;: \&quot;jesus christ\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;genre\&quot;,             \&quot;value\&quot;: \&quot;religion\&quot;,             \&quot;negate\&quot;: true         }         {             \&quot;AND\&quot;: [                 {                     \&quot;key\&quot;: \&quot;subject\&quot;,                     \&quot;value\&quot;: \&quot;tao-te-ching\&quot;,                     \&quot;negate\&quot;: false                 },                 {                     \&quot;key\&quot;: \&quot;author\&quot;,                     \&quot;value\&quot;: \&quot;lao-tzu\&quot;,                     \&quot;negate\&quot;: false                 }             ]         }     ] } &#x60;&#x60;&#x60; In this case, files will be filtered such that: 1. \&quot;subject\&quot; &#x3D; \&quot;holy-bible\&quot; OR 2. \&quot;person-of-interest\&quot; &#x3D; \&quot;jesus christ\&quot; OR 3. \&quot;genre\&quot; !&#x3D; \&quot;religion\&quot; OR 4. \&quot;subject\&quot; &#x3D; \&quot;tao-te-ching\&quot; AND \&quot;author\&quot; &#x3D; \&quot;lao-tzu\&quot;  Note that the top level of the query must be either an \&quot;OR\&quot; or \&quot;AND\&quot; array. Currently, nesting is limited to 3. For tag blocks (those with \&quot;key\&quot;, \&quot;value\&quot;, and \&quot;negate\&quot; keys), the following typing rules apply: 1. \&quot;key\&quot; isn&#39;t optional and must be a &#x60;string&#x60; 2. \&quot;value\&quot; isn&#39;t optional and can be &#x60;any&#x60; or list[&#x60;any&#x60;] 3. \&quot;negate\&quot; is optional and must be &#x60;true&#x60; or &#x60;false&#x60;. If present and &#x60;true&#x60;, then the filter block is negated in the resulting query. It is &#x60;false&#x60; by default.
     */
    open func queryUserFilesWithRequestBuilder(
            organizationUserFilesToSyncQueryInput: OrganizationUserFilesToSyncQueryInput
    ) -> RequestBuilder<UserFilesV2> {
        let basePath = self.client!.basePath;
        let localVariablePath = "/user_files_v2"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: organizationUserFilesToSyncQueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client!.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFilesV2>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /user_files_v2")
    }


    /**
     User Files
     
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @discardableResult
    open class func queryUserFilesDeprecatedSync(organizationUserFilesToSyncQueryInput: OrganizationUserFilesToSyncQueryInput, apiResponseQueue: DispatchQueue = CarbonAIAPI.apiResponseQueue, completion: @escaping ((_ data: [UserFile]?, _ error: Error?) -> Void)) -> RequestTask {
        return queryUserFilesDeprecatedWithRequestBuilder(organizationUserFilesToSyncQueryInput: organizationUserFilesToSyncQueryInput).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     User Files
     
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func queryUserFilesDeprecatedAsyncMappedParams(organizationUserFilesToSyncQueryInput: OrganizationUserFilesToSyncQueryInput) async throws -> [UserFile] {
        return try await withCheckedThrowingContinuation { continuation in
            queryUserFilesDeprecatedWithRequestBuilder(organizationUserFilesToSyncQueryInput: organizationUserFilesToSyncQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     User Files
     
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func queryUserFilesDeprecated(
        pagination: Pagination? = nil, 
        orderBy: OrganizationUserFilesToSyncOrderByTypes? = nil, 
        orderDir: OrderDir? = nil, 
        filters: OrganizationUserFilesToSyncFilters? = nil, 
        includeRawFile: Bool? = nil, 
        includeParsedTextFile: Bool? = nil, 
        includeAdditionalFiles: Bool? = nil
    ) async throws -> [UserFile] {
        let organizationUserFilesToSyncQueryInput = OrganizationUserFilesToSyncQueryInput(
            pagination: pagination,
            orderBy: orderBy,
            orderDir: orderDir,
            filters: filters,
            includeRawFile: includeRawFile,
            includeParsedTextFile: includeParsedTextFile,
            includeAdditionalFiles: includeAdditionalFiles
        )
        return try await withCheckedThrowingContinuation { continuation in
            queryUserFilesDeprecatedWithRequestBuilder(organizationUserFilesToSyncQueryInput: organizationUserFilesToSyncQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     User Files
     
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func queryUserFilesDeprecated(
        pagination: Pagination? = nil, 
        orderBy: OrganizationUserFilesToSyncOrderByTypes? = nil, 
        orderDir: OrderDir? = nil, 
        filters: OrganizationUserFilesToSyncFilters? = nil, 
        includeRawFile: Bool? = nil, 
        includeParsedTextFile: Bool? = nil, 
        includeAdditionalFiles: Bool? = nil
    ) async throws -> [UserFile] {
        let organizationUserFilesToSyncQueryInput = OrganizationUserFilesToSyncQueryInput(
            pagination: pagination,
            orderBy: orderBy,
            orderDir: orderDir,
            filters: filters,
            includeRawFile: includeRawFile,
            includeParsedTextFile: includeParsedTextFile,
            includeAdditionalFiles: includeAdditionalFiles
        )
        return try await withCheckedThrowingContinuation { continuation in
            queryUserFilesDeprecatedWithRequestBuilder(organizationUserFilesToSyncQueryInput: organizationUserFilesToSyncQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     User Files
     - POST /user_files
     - This route is deprecated. Use `/user_files_v2` instead.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - returns: RequestBuilder<[UserFile]> This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open class func queryUserFilesDeprecatedWithRequestBuilder(
            organizationUserFilesToSyncQueryInput: OrganizationUserFilesToSyncQueryInput
    ) -> RequestBuilder<[UserFile]> {
        let basePath = CarbonAIAPI.basePath;
        let localVariablePath = "/user_files"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: organizationUserFilesToSyncQueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAIAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<[UserFile]>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /user_files")
    }

    /**
     User Files
     - POST /user_files
     - This route is deprecated. Use `/user_files_v2` instead.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter organizationUserFilesToSyncQueryInput: (body)  
     - returns: RequestBuilder<[UserFile]> This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open func queryUserFilesDeprecatedWithRequestBuilder(
            organizationUserFilesToSyncQueryInput: OrganizationUserFilesToSyncQueryInput
    ) -> RequestBuilder<[UserFile]> {
        let basePath = self.client!.basePath;
        let localVariablePath = "/user_files"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: organizationUserFilesToSyncQueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client!.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<[UserFile]>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /user_files")
    }


    /**
     Resync File
     
     - parameter resyncFileQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func resyncSync(resyncFileQueryInput: ResyncFileQueryInput, apiResponseQueue: DispatchQueue = CarbonAIAPI.apiResponseQueue, completion: @escaping ((_ data: UserFile?, _ error: Error?) -> Void)) -> RequestTask {
        return resyncWithRequestBuilder(resyncFileQueryInput: resyncFileQueryInput).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Resync File
     
     - parameter resyncFileQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func resyncAsyncMappedParams(resyncFileQueryInput: ResyncFileQueryInput) async throws -> UserFile {
        return try await withCheckedThrowingContinuation { continuation in
            resyncWithRequestBuilder(resyncFileQueryInput: resyncFileQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Resync File
     
     - parameter resyncFileQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func resync(
        fileId: Int,
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        forceEmbeddingGeneration: Bool? = nil, 
        skipFileProcessing: Bool? = nil
    ) async throws -> UserFile {
        let resyncFileQueryInput = ResyncFileQueryInput(
            fileId: fileId,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            forceEmbeddingGeneration: forceEmbeddingGeneration,
            skipFileProcessing: skipFileProcessing
        )
        return try await withCheckedThrowingContinuation { continuation in
            resyncWithRequestBuilder(resyncFileQueryInput: resyncFileQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Resync File
     
     - parameter resyncFileQueryInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func resync(
        fileId: Int,
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        forceEmbeddingGeneration: Bool? = nil, 
        skipFileProcessing: Bool? = nil
    ) async throws -> UserFile {
        let resyncFileQueryInput = ResyncFileQueryInput(
            fileId: fileId,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            forceEmbeddingGeneration: forceEmbeddingGeneration,
            skipFileProcessing: skipFileProcessing
        )
        return try await withCheckedThrowingContinuation { continuation in
            resyncWithRequestBuilder(resyncFileQueryInput: resyncFileQueryInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Resync File
     - POST /resync_file
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter resyncFileQueryInput: (body)  
     - returns: RequestBuilder<UserFile> 
     */
    open class func resyncWithRequestBuilder(
            resyncFileQueryInput: ResyncFileQueryInput
    ) -> RequestBuilder<UserFile> {
        let basePath = CarbonAIAPI.basePath;
        let localVariablePath = "/resync_file"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: resyncFileQueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAIAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /resync_file")
    }

    /**
     Resync File
     - POST /resync_file
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter resyncFileQueryInput: (body)  
     - returns: RequestBuilder<UserFile> 
     */
    open func resyncWithRequestBuilder(
            resyncFileQueryInput: ResyncFileQueryInput
    ) -> RequestBuilder<UserFile> {
        let basePath = self.client!.basePath;
        let localVariablePath = "/resync_file"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: resyncFileQueryInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client!.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /resync_file")
    }


    /**
     Create Upload File
     
     - parameter file: (form)  
     - parameter bodyCreateUploadFileUploadfilePost: (body)  
     - parameter chunkSize: (query) Chunk size in tiktoken tokens to be used when processing file. (optional)
     - parameter chunkOverlap: (query) Chunk overlap in tiktoken tokens to be used when processing file. (optional)
     - parameter skipEmbeddingGeneration: (query) Flag to control whether or not embeddings should be generated and stored             when processing file. (optional, default to false)
     - parameter setPageAsBoundary: (query) Flag to control whether or not to set the a page&#39;s worth of content as the maximum             amount of content that can appear in a chunk. Only valid for PDFs. See description route description for             more information. (optional, default to false)
     - parameter embeddingModel: (query) Embedding model that will be used to embed file chunks. (optional)
     - parameter useOcr: (query) Whether or not to use OCR when processing files. Valid for PDFs, JPEGs, and PNGs. Useful for documents with             tables, images, and/or scanned text. (optional, default to false)
     - parameter generateSparseVectors: (query) Whether or not to generate sparse vectors for the file. This is *required* for the file to be a             candidate for hybrid search. (optional, default to false)
     - parameter prependFilenameToChunks: (query) Whether or not to prepend the file&#39;s name to chunks. (optional, default to false)
     - parameter maxItemsPerChunk: (query) Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
     - parameter parsePdfTablesWithOcr: (query) Whether to use rich table parsing when &#x60;use_ocr&#x60; is enabled. (optional, default to false)
     - parameter detectAudioLanguage: (query) Whether to automatically detect the language of the uploaded audio file. (optional, default to false)
     - parameter transcriptionService: (query) The transcription service to use for audio files. If no service is specified, &#39;deepgram&#39; will be used. (optional)
     - parameter includeSpeakerLabels: (query) Detect multiple speakers and label segments of speech by speaker for audio files. (optional, default to false)
     - parameter mediaType: (query) The media type of the file. If not provided, it will be inferred from the file extension. (optional)
     - parameter splitRows: (query) Whether to split tabular rows into chunks. Currently only valid for CSV, TSV, and XLSX files. (optional, default to false)
     - parameter enableColdStorage: (query) Enable cold storage for the file. If set to true, the file will be moved to cold storage after a certain period of inactivity. Default is false. (optional, default to false)
     - parameter hotStorageTimeToLive: (query) Time in seconds after which the file will be moved to cold storage. (optional)
     - parameter generateChunksOnly: (query) If this flag is enabled, the file will be chunked and stored with Carbon,             but no embeddings will be generated. This overrides the skip_embedding_generation flag. (optional, default to false)
     - parameter storeFileOnly: (query) If this flag is enabled, the file will be stored with Carbon, but no processing will be done. (optional, default to false)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func uploadSync(file: URL, bodyCreateUploadFileUploadfilePost: BodyCreateUploadFileUploadfilePost, chunkSize: Int? = nil, chunkOverlap: Int? = nil, skipEmbeddingGeneration: Bool? = nil, setPageAsBoundary: Bool? = nil, embeddingModel: EmbeddingModel? = nil, useOcr: Bool? = nil, generateSparseVectors: Bool? = nil, prependFilenameToChunks: Bool? = nil, maxItemsPerChunk: Int? = nil, parsePdfTablesWithOcr: Bool? = nil, detectAudioLanguage: Bool? = nil, transcriptionService: TranscriptionServiceNullable? = nil, includeSpeakerLabels: Bool? = nil, mediaType: FileContentTypesNullable? = nil, splitRows: Bool? = nil, enableColdStorage: Bool? = nil, hotStorageTimeToLive: Int? = nil, generateChunksOnly: Bool? = nil, storeFileOnly: Bool? = nil, apiResponseQueue: DispatchQueue = CarbonAIAPI.apiResponseQueue, completion: @escaping ((_ data: UserFile?, _ error: Error?) -> Void)) -> RequestTask {
        return uploadWithRequestBuilder(file: file, bodyCreateUploadFileUploadfilePost: bodyCreateUploadFileUploadfilePost, chunkSize: chunkSize, chunkOverlap: chunkOverlap, skipEmbeddingGeneration: skipEmbeddingGeneration, setPageAsBoundary: setPageAsBoundary, embeddingModel: embeddingModel, useOcr: useOcr, generateSparseVectors: generateSparseVectors, prependFilenameToChunks: prependFilenameToChunks, maxItemsPerChunk: maxItemsPerChunk, parsePdfTablesWithOcr: parsePdfTablesWithOcr, detectAudioLanguage: detectAudioLanguage, transcriptionService: transcriptionService, includeSpeakerLabels: includeSpeakerLabels, mediaType: mediaType, splitRows: splitRows, enableColdStorage: enableColdStorage, hotStorageTimeToLive: hotStorageTimeToLive, generateChunksOnly: generateChunksOnly, storeFileOnly: storeFileOnly).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Create Upload File
     
     - parameter file: (form)  
     - parameter bodyCreateUploadFileUploadfilePost: (body)  
     - parameter chunkSize: (query) Chunk size in tiktoken tokens to be used when processing file. (optional)
     - parameter chunkOverlap: (query) Chunk overlap in tiktoken tokens to be used when processing file. (optional)
     - parameter skipEmbeddingGeneration: (query) Flag to control whether or not embeddings should be generated and stored             when processing file. (optional, default to false)
     - parameter setPageAsBoundary: (query) Flag to control whether or not to set the a page&#39;s worth of content as the maximum             amount of content that can appear in a chunk. Only valid for PDFs. See description route description for             more information. (optional, default to false)
     - parameter embeddingModel: (query) Embedding model that will be used to embed file chunks. (optional)
     - parameter useOcr: (query) Whether or not to use OCR when processing files. Valid for PDFs, JPEGs, and PNGs. Useful for documents with             tables, images, and/or scanned text. (optional, default to false)
     - parameter generateSparseVectors: (query) Whether or not to generate sparse vectors for the file. This is *required* for the file to be a             candidate for hybrid search. (optional, default to false)
     - parameter prependFilenameToChunks: (query) Whether or not to prepend the file&#39;s name to chunks. (optional, default to false)
     - parameter maxItemsPerChunk: (query) Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
     - parameter parsePdfTablesWithOcr: (query) Whether to use rich table parsing when &#x60;use_ocr&#x60; is enabled. (optional, default to false)
     - parameter detectAudioLanguage: (query) Whether to automatically detect the language of the uploaded audio file. (optional, default to false)
     - parameter transcriptionService: (query) The transcription service to use for audio files. If no service is specified, &#39;deepgram&#39; will be used. (optional)
     - parameter includeSpeakerLabels: (query) Detect multiple speakers and label segments of speech by speaker for audio files. (optional, default to false)
     - parameter mediaType: (query) The media type of the file. If not provided, it will be inferred from the file extension. (optional)
     - parameter splitRows: (query) Whether to split tabular rows into chunks. Currently only valid for CSV, TSV, and XLSX files. (optional, default to false)
     - parameter enableColdStorage: (query) Enable cold storage for the file. If set to true, the file will be moved to cold storage after a certain period of inactivity. Default is false. (optional, default to false)
     - parameter hotStorageTimeToLive: (query) Time in seconds after which the file will be moved to cold storage. (optional)
     - parameter generateChunksOnly: (query) If this flag is enabled, the file will be chunked and stored with Carbon,             but no embeddings will be generated. This overrides the skip_embedding_generation flag. (optional, default to false)
     - parameter storeFileOnly: (query) If this flag is enabled, the file will be stored with Carbon, but no processing will be done. (optional, default to false)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func uploadAsyncMappedParams(file: URL, bodyCreateUploadFileUploadfilePost: BodyCreateUploadFileUploadfilePost, chunkSize: Int? = nil, chunkOverlap: Int? = nil, skipEmbeddingGeneration: Bool? = nil, setPageAsBoundary: Bool? = nil, embeddingModel: EmbeddingModel? = nil, useOcr: Bool? = nil, generateSparseVectors: Bool? = nil, prependFilenameToChunks: Bool? = nil, maxItemsPerChunk: Int? = nil, parsePdfTablesWithOcr: Bool? = nil, detectAudioLanguage: Bool? = nil, transcriptionService: TranscriptionServiceNullable? = nil, includeSpeakerLabels: Bool? = nil, mediaType: FileContentTypesNullable? = nil, splitRows: Bool? = nil, enableColdStorage: Bool? = nil, hotStorageTimeToLive: Int? = nil, generateChunksOnly: Bool? = nil, storeFileOnly: Bool? = nil) async throws -> UserFile {
        return try await withCheckedThrowingContinuation { continuation in
            uploadWithRequestBuilder(file: file, bodyCreateUploadFileUploadfilePost: bodyCreateUploadFileUploadfilePost, chunkSize: chunkSize, chunkOverlap: chunkOverlap, skipEmbeddingGeneration: skipEmbeddingGeneration, setPageAsBoundary: setPageAsBoundary, embeddingModel: embeddingModel, useOcr: useOcr, generateSparseVectors: generateSparseVectors, prependFilenameToChunks: prependFilenameToChunks, maxItemsPerChunk: maxItemsPerChunk, parsePdfTablesWithOcr: parsePdfTablesWithOcr, detectAudioLanguage: detectAudioLanguage, transcriptionService: transcriptionService, includeSpeakerLabels: includeSpeakerLabels, mediaType: mediaType, splitRows: splitRows, enableColdStorage: enableColdStorage, hotStorageTimeToLive: hotStorageTimeToLive, generateChunksOnly: generateChunksOnly, storeFileOnly: storeFileOnly).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Create Upload File
     
     - parameter file: (form)  
     - parameter bodyCreateUploadFileUploadfilePost: (body)  
     - parameter chunkSize: (query) Chunk size in tiktoken tokens to be used when processing file. (optional)
     - parameter chunkOverlap: (query) Chunk overlap in tiktoken tokens to be used when processing file. (optional)
     - parameter skipEmbeddingGeneration: (query) Flag to control whether or not embeddings should be generated and stored             when processing file. (optional, default to false)
     - parameter setPageAsBoundary: (query) Flag to control whether or not to set the a page&#39;s worth of content as the maximum             amount of content that can appear in a chunk. Only valid for PDFs. See description route description for             more information. (optional, default to false)
     - parameter embeddingModel: (query) Embedding model that will be used to embed file chunks. (optional)
     - parameter useOcr: (query) Whether or not to use OCR when processing files. Valid for PDFs, JPEGs, and PNGs. Useful for documents with             tables, images, and/or scanned text. (optional, default to false)
     - parameter generateSparseVectors: (query) Whether or not to generate sparse vectors for the file. This is *required* for the file to be a             candidate for hybrid search. (optional, default to false)
     - parameter prependFilenameToChunks: (query) Whether or not to prepend the file&#39;s name to chunks. (optional, default to false)
     - parameter maxItemsPerChunk: (query) Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
     - parameter parsePdfTablesWithOcr: (query) Whether to use rich table parsing when &#x60;use_ocr&#x60; is enabled. (optional, default to false)
     - parameter detectAudioLanguage: (query) Whether to automatically detect the language of the uploaded audio file. (optional, default to false)
     - parameter transcriptionService: (query) The transcription service to use for audio files. If no service is specified, &#39;deepgram&#39; will be used. (optional)
     - parameter includeSpeakerLabels: (query) Detect multiple speakers and label segments of speech by speaker for audio files. (optional, default to false)
     - parameter mediaType: (query) The media type of the file. If not provided, it will be inferred from the file extension. (optional)
     - parameter splitRows: (query) Whether to split tabular rows into chunks. Currently only valid for CSV, TSV, and XLSX files. (optional, default to false)
     - parameter enableColdStorage: (query) Enable cold storage for the file. If set to true, the file will be moved to cold storage after a certain period of inactivity. Default is false. (optional, default to false)
     - parameter hotStorageTimeToLive: (query) Time in seconds after which the file will be moved to cold storage. (optional)
     - parameter generateChunksOnly: (query) If this flag is enabled, the file will be chunked and stored with Carbon,             but no embeddings will be generated. This overrides the skip_embedding_generation flag. (optional, default to false)
     - parameter storeFileOnly: (query) If this flag is enabled, the file will be stored with Carbon, but no processing will be done. (optional, default to false)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func upload(
        file: URL,
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        setPageAsBoundary: Bool? = nil, 
        embeddingModel: EmbeddingModel? = nil, 
        useOcr: Bool? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        maxItemsPerChunk: Int? = nil, 
        parsePdfTablesWithOcr: Bool? = nil, 
        detectAudioLanguage: Bool? = nil, 
        transcriptionService: TranscriptionServiceNullable? = nil, 
        includeSpeakerLabels: Bool? = nil, 
        mediaType: FileContentTypesNullable? = nil, 
        splitRows: Bool? = nil, 
        enableColdStorage: Bool? = nil, 
        hotStorageTimeToLive: Int? = nil, 
        generateChunksOnly: Bool? = nil, 
        storeFileOnly: Bool? = nil
    ) async throws -> UserFile {
        let bodyCreateUploadFileUploadfilePost = BodyCreateUploadFileUploadfilePost(
            file: file
        )
        return try await withCheckedThrowingContinuation { continuation in
            uploadWithRequestBuilder(file: file, bodyCreateUploadFileUploadfilePost: bodyCreateUploadFileUploadfilePost, chunkSize: chunkSize, chunkOverlap: chunkOverlap, skipEmbeddingGeneration: skipEmbeddingGeneration, setPageAsBoundary: setPageAsBoundary, embeddingModel: embeddingModel, useOcr: useOcr, generateSparseVectors: generateSparseVectors, prependFilenameToChunks: prependFilenameToChunks, maxItemsPerChunk: maxItemsPerChunk, parsePdfTablesWithOcr: parsePdfTablesWithOcr, detectAudioLanguage: detectAudioLanguage, transcriptionService: transcriptionService, includeSpeakerLabels: includeSpeakerLabels, mediaType: mediaType, splitRows: splitRows, enableColdStorage: enableColdStorage, hotStorageTimeToLive: hotStorageTimeToLive, generateChunksOnly: generateChunksOnly, storeFileOnly: storeFileOnly).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Create Upload File
     
     - parameter file: (form)  
     - parameter bodyCreateUploadFileUploadfilePost: (body)  
     - parameter chunkSize: (query) Chunk size in tiktoken tokens to be used when processing file. (optional)
     - parameter chunkOverlap: (query) Chunk overlap in tiktoken tokens to be used when processing file. (optional)
     - parameter skipEmbeddingGeneration: (query) Flag to control whether or not embeddings should be generated and stored             when processing file. (optional, default to false)
     - parameter setPageAsBoundary: (query) Flag to control whether or not to set the a page&#39;s worth of content as the maximum             amount of content that can appear in a chunk. Only valid for PDFs. See description route description for             more information. (optional, default to false)
     - parameter embeddingModel: (query) Embedding model that will be used to embed file chunks. (optional)
     - parameter useOcr: (query) Whether or not to use OCR when processing files. Valid for PDFs, JPEGs, and PNGs. Useful for documents with             tables, images, and/or scanned text. (optional, default to false)
     - parameter generateSparseVectors: (query) Whether or not to generate sparse vectors for the file. This is *required* for the file to be a             candidate for hybrid search. (optional, default to false)
     - parameter prependFilenameToChunks: (query) Whether or not to prepend the file&#39;s name to chunks. (optional, default to false)
     - parameter maxItemsPerChunk: (query) Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
     - parameter parsePdfTablesWithOcr: (query) Whether to use rich table parsing when &#x60;use_ocr&#x60; is enabled. (optional, default to false)
     - parameter detectAudioLanguage: (query) Whether to automatically detect the language of the uploaded audio file. (optional, default to false)
     - parameter transcriptionService: (query) The transcription service to use for audio files. If no service is specified, &#39;deepgram&#39; will be used. (optional)
     - parameter includeSpeakerLabels: (query) Detect multiple speakers and label segments of speech by speaker for audio files. (optional, default to false)
     - parameter mediaType: (query) The media type of the file. If not provided, it will be inferred from the file extension. (optional)
     - parameter splitRows: (query) Whether to split tabular rows into chunks. Currently only valid for CSV, TSV, and XLSX files. (optional, default to false)
     - parameter enableColdStorage: (query) Enable cold storage for the file. If set to true, the file will be moved to cold storage after a certain period of inactivity. Default is false. (optional, default to false)
     - parameter hotStorageTimeToLive: (query) Time in seconds after which the file will be moved to cold storage. (optional)
     - parameter generateChunksOnly: (query) If this flag is enabled, the file will be chunked and stored with Carbon,             but no embeddings will be generated. This overrides the skip_embedding_generation flag. (optional, default to false)
     - parameter storeFileOnly: (query) If this flag is enabled, the file will be stored with Carbon, but no processing will be done. (optional, default to false)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func upload(
        file: URL,
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        setPageAsBoundary: Bool? = nil, 
        embeddingModel: EmbeddingModel? = nil, 
        useOcr: Bool? = nil, 
        generateSparseVectors: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        maxItemsPerChunk: Int? = nil, 
        parsePdfTablesWithOcr: Bool? = nil, 
        detectAudioLanguage: Bool? = nil, 
        transcriptionService: TranscriptionServiceNullable? = nil, 
        includeSpeakerLabels: Bool? = nil, 
        mediaType: FileContentTypesNullable? = nil, 
        splitRows: Bool? = nil, 
        enableColdStorage: Bool? = nil, 
        hotStorageTimeToLive: Int? = nil, 
        generateChunksOnly: Bool? = nil, 
        storeFileOnly: Bool? = nil
    ) async throws -> UserFile {
        let bodyCreateUploadFileUploadfilePost = BodyCreateUploadFileUploadfilePost(
            file: file
        )
        return try await withCheckedThrowingContinuation { continuation in
            uploadWithRequestBuilder(file: file, bodyCreateUploadFileUploadfilePost: bodyCreateUploadFileUploadfilePost, chunkSize: chunkSize, chunkOverlap: chunkOverlap, skipEmbeddingGeneration: skipEmbeddingGeneration, setPageAsBoundary: setPageAsBoundary, embeddingModel: embeddingModel, useOcr: useOcr, generateSparseVectors: generateSparseVectors, prependFilenameToChunks: prependFilenameToChunks, maxItemsPerChunk: maxItemsPerChunk, parsePdfTablesWithOcr: parsePdfTablesWithOcr, detectAudioLanguage: detectAudioLanguage, transcriptionService: transcriptionService, includeSpeakerLabels: includeSpeakerLabels, mediaType: mediaType, splitRows: splitRows, enableColdStorage: enableColdStorage, hotStorageTimeToLive: hotStorageTimeToLive, generateChunksOnly: generateChunksOnly, storeFileOnly: storeFileOnly).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Create Upload File
     - POST /uploadfile
     - This endpoint is used to directly upload local files to Carbon. The `POST` request should be a multipart form request. Note that the `set_page_as_boundary` query parameter is applicable only to PDFs for now. When this value is set, PDF chunks are at most one page long. Additional information can be retrieved for each chunk, however, namely the coordinates of the bounding box around the chunk (this can be used for things like text highlighting). Following is a description of all possible query parameters: - `chunk_size`: the chunk size (in tokens) applied when splitting the document - `chunk_overlap`: the chunk overlap (in tokens) applied when splitting the document - `skip_embedding_generation`: whether or not to skip the generation of chunks and embeddings - `set_page_as_boundary`: described above - `embedding_model`: the model used to generate embeddings for the document chunks - `use_ocr`: whether or not to use OCR as a preprocessing step prior to generating chunks. Valid for PDFs, JPEGs, and PNGs - `generate_sparse_vectors`: whether or not to generate sparse vectors for the file. Required for hybrid search. - `prepend_filename_to_chunks`: whether or not to prepend the filename to the chunk text   Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI's multimodal model; for text, we support OpenAI's `text-embedding-ada-002` and Cohere's embed-multilingual-v3.0. The model can be specified via the `embedding_model` parameter (in the POST body for `/embeddings`, and a query  parameter in `/uploadfile`). If no model is supplied, the `text-embedding-ada-002` is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with `OPENAI`, and files C and D have embeddings generated with `COHERE_MULTILINGUAL_V3`, then by default, queries will only consider files A and B. If `COHERE_MULTILINGUAL_V3` is specified as the `embedding_model` in `/embeddings`, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set `VERTEX_MULTIMODAL` as an `embedding_model`. This model is used automatically by Carbon when it detects an image file.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter file: (form)  
     - parameter bodyCreateUploadFileUploadfilePost: (body)  
     - parameter chunkSize: (query) Chunk size in tiktoken tokens to be used when processing file. (optional)
     - parameter chunkOverlap: (query) Chunk overlap in tiktoken tokens to be used when processing file. (optional)
     - parameter skipEmbeddingGeneration: (query) Flag to control whether or not embeddings should be generated and stored             when processing file. (optional, default to false)
     - parameter setPageAsBoundary: (query) Flag to control whether or not to set the a page&#39;s worth of content as the maximum             amount of content that can appear in a chunk. Only valid for PDFs. See description route description for             more information. (optional, default to false)
     - parameter embeddingModel: (query) Embedding model that will be used to embed file chunks. (optional)
     - parameter useOcr: (query) Whether or not to use OCR when processing files. Valid for PDFs, JPEGs, and PNGs. Useful for documents with             tables, images, and/or scanned text. (optional, default to false)
     - parameter generateSparseVectors: (query) Whether or not to generate sparse vectors for the file. This is *required* for the file to be a             candidate for hybrid search. (optional, default to false)
     - parameter prependFilenameToChunks: (query) Whether or not to prepend the file&#39;s name to chunks. (optional, default to false)
     - parameter maxItemsPerChunk: (query) Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
     - parameter parsePdfTablesWithOcr: (query) Whether to use rich table parsing when &#x60;use_ocr&#x60; is enabled. (optional, default to false)
     - parameter detectAudioLanguage: (query) Whether to automatically detect the language of the uploaded audio file. (optional, default to false)
     - parameter transcriptionService: (query) The transcription service to use for audio files. If no service is specified, &#39;deepgram&#39; will be used. (optional)
     - parameter includeSpeakerLabels: (query) Detect multiple speakers and label segments of speech by speaker for audio files. (optional, default to false)
     - parameter mediaType: (query) The media type of the file. If not provided, it will be inferred from the file extension. (optional)
     - parameter splitRows: (query) Whether to split tabular rows into chunks. Currently only valid for CSV, TSV, and XLSX files. (optional, default to false)
     - parameter enableColdStorage: (query) Enable cold storage for the file. If set to true, the file will be moved to cold storage after a certain period of inactivity. Default is false. (optional, default to false)
     - parameter hotStorageTimeToLive: (query) Time in seconds after which the file will be moved to cold storage. (optional)
     - parameter generateChunksOnly: (query) If this flag is enabled, the file will be chunked and stored with Carbon,             but no embeddings will be generated. This overrides the skip_embedding_generation flag. (optional, default to false)
     - parameter storeFileOnly: (query) If this flag is enabled, the file will be stored with Carbon, but no processing will be done. (optional, default to false)
     - returns: RequestBuilder<UserFile> This endpoint is used to directly upload local files to Carbon. The &#x60;POST&#x60; request should be a multipart form request. Note that the &#x60;set_page_as_boundary&#x60; query parameter is applicable only to PDFs for now. When this value is set, PDF chunks are at most one page long. Additional information can be retrieved for each chunk, however, namely the coordinates of the bounding box around the chunk (this can be used for things like text highlighting). Following is a description of all possible query parameters: - &#x60;chunk_size&#x60;: the chunk size (in tokens) applied when splitting the document - &#x60;chunk_overlap&#x60;: the chunk overlap (in tokens) applied when splitting the document - &#x60;skip_embedding_generation&#x60;: whether or not to skip the generation of chunks and embeddings - &#x60;set_page_as_boundary&#x60;: described above - &#x60;embedding_model&#x60;: the model used to generate embeddings for the document chunks - &#x60;use_ocr&#x60;: whether or not to use OCR as a preprocessing step prior to generating chunks. Valid for PDFs, JPEGs, and PNGs - &#x60;generate_sparse_vectors&#x60;: whether or not to generate sparse vectors for the file. Required for hybrid search. - &#x60;prepend_filename_to_chunks&#x60;: whether or not to prepend the filename to the chunk text   Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI&#39;s multimodal model; for text, we support OpenAI&#39;s &#x60;text-embedding-ada-002&#x60; and Cohere&#39;s embed-multilingual-v3.0. The model can be specified via the &#x60;embedding_model&#x60; parameter (in the POST body for &#x60;/embeddings&#x60;, and a query  parameter in &#x60;/uploadfile&#x60;). If no model is supplied, the &#x60;text-embedding-ada-002&#x60; is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with &#x60;OPENAI&#x60;, and files C and D have embeddings generated with &#x60;COHERE_MULTILINGUAL_V3&#x60;, then by default, queries will only consider files A and B. If &#x60;COHERE_MULTILINGUAL_V3&#x60; is specified as the &#x60;embedding_model&#x60; in &#x60;/embeddings&#x60;, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set &#x60;VERTEX_MULTIMODAL&#x60; as an &#x60;embedding_model&#x60;. This model is used automatically by Carbon when it detects an image file.
     */
    open class func uploadWithRequestBuilder(
            file: URL,
            bodyCreateUploadFileUploadfilePost: BodyCreateUploadFileUploadfilePost,
            chunkSize: Int? = nil,
            chunkOverlap: Int? = nil,
            skipEmbeddingGeneration: Bool? = nil,
            setPageAsBoundary: Bool? = nil,
            embeddingModel: EmbeddingModel? = nil,
            useOcr: Bool? = nil,
            generateSparseVectors: Bool? = nil,
            prependFilenameToChunks: Bool? = nil,
            maxItemsPerChunk: Int? = nil,
            parsePdfTablesWithOcr: Bool? = nil,
            detectAudioLanguage: Bool? = nil,
            transcriptionService: TranscriptionServiceNullable? = nil,
            includeSpeakerLabels: Bool? = nil,
            mediaType: FileContentTypesNullable? = nil,
            splitRows: Bool? = nil,
            enableColdStorage: Bool? = nil,
            hotStorageTimeToLive: Int? = nil,
            generateChunksOnly: Bool? = nil,
            storeFileOnly: Bool? = nil
    ) -> RequestBuilder<UserFile> {
        let basePath = CarbonAIAPI.basePath;
        let localVariablePath = "/uploadfile"
        let localVariableURLString = basePath + localVariablePath
        let localVariableFormParams: [String: Any?] = [
            "file": file.encodeToJSON(),
        ]

        let localVariableNonNullParameters = APIHelper.rejectNil(localVariableFormParams)
        let localVariableParameters = APIHelper.convertBoolToString(localVariableNonNullParameters)
        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "chunk_size": (wrappedValue: chunkSize?.encodeToJSON(), isExplode: true),
            "chunk_overlap": (wrappedValue: chunkOverlap?.encodeToJSON(), isExplode: true),
            "skip_embedding_generation": (wrappedValue: skipEmbeddingGeneration?.encodeToJSON(), isExplode: true),
            "set_page_as_boundary": (wrappedValue: setPageAsBoundary?.encodeToJSON(), isExplode: true),
            "embedding_model": (wrappedValue: embeddingModel?.encodeToJSON(), isExplode: true),
            "use_ocr": (wrappedValue: useOcr?.encodeToJSON(), isExplode: true),
            "generate_sparse_vectors": (wrappedValue: generateSparseVectors?.encodeToJSON(), isExplode: true),
            "prepend_filename_to_chunks": (wrappedValue: prependFilenameToChunks?.encodeToJSON(), isExplode: true),
            "max_items_per_chunk": (wrappedValue: maxItemsPerChunk?.encodeToJSON(), isExplode: true),
            "parse_pdf_tables_with_ocr": (wrappedValue: parsePdfTablesWithOcr?.encodeToJSON(), isExplode: true),
            "detect_audio_language": (wrappedValue: detectAudioLanguage?.encodeToJSON(), isExplode: true),
            "transcription_service": (wrappedValue: transcriptionService?.encodeToJSON(), isExplode: true),
            "include_speaker_labels": (wrappedValue: includeSpeakerLabels?.encodeToJSON(), isExplode: true),
            "media_type": (wrappedValue: mediaType?.encodeToJSON(), isExplode: true),
            "split_rows": (wrappedValue: splitRows?.encodeToJSON(), isExplode: true),
            "enable_cold_storage": (wrappedValue: enableColdStorage?.encodeToJSON(), isExplode: true),
            "hot_storage_time_to_live": (wrappedValue: hotStorageTimeToLive?.encodeToJSON(), isExplode: true),
            "generate_chunks_only": (wrappedValue: generateChunksOnly?.encodeToJSON(), isExplode: true),
            "store_file_only": (wrappedValue: storeFileOnly?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "multipart/form-data",
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAIAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /uploadfile")
    }

    /**
     Create Upload File
     - POST /uploadfile
     - This endpoint is used to directly upload local files to Carbon. The `POST` request should be a multipart form request. Note that the `set_page_as_boundary` query parameter is applicable only to PDFs for now. When this value is set, PDF chunks are at most one page long. Additional information can be retrieved for each chunk, however, namely the coordinates of the bounding box around the chunk (this can be used for things like text highlighting). Following is a description of all possible query parameters: - `chunk_size`: the chunk size (in tokens) applied when splitting the document - `chunk_overlap`: the chunk overlap (in tokens) applied when splitting the document - `skip_embedding_generation`: whether or not to skip the generation of chunks and embeddings - `set_page_as_boundary`: described above - `embedding_model`: the model used to generate embeddings for the document chunks - `use_ocr`: whether or not to use OCR as a preprocessing step prior to generating chunks. Valid for PDFs, JPEGs, and PNGs - `generate_sparse_vectors`: whether or not to generate sparse vectors for the file. Required for hybrid search. - `prepend_filename_to_chunks`: whether or not to prepend the filename to the chunk text   Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI's multimodal model; for text, we support OpenAI's `text-embedding-ada-002` and Cohere's embed-multilingual-v3.0. The model can be specified via the `embedding_model` parameter (in the POST body for `/embeddings`, and a query  parameter in `/uploadfile`). If no model is supplied, the `text-embedding-ada-002` is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with `OPENAI`, and files C and D have embeddings generated with `COHERE_MULTILINGUAL_V3`, then by default, queries will only consider files A and B. If `COHERE_MULTILINGUAL_V3` is specified as the `embedding_model` in `/embeddings`, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set `VERTEX_MULTIMODAL` as an `embedding_model`. This model is used automatically by Carbon when it detects an image file.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter file: (form)  
     - parameter bodyCreateUploadFileUploadfilePost: (body)  
     - parameter chunkSize: (query) Chunk size in tiktoken tokens to be used when processing file. (optional)
     - parameter chunkOverlap: (query) Chunk overlap in tiktoken tokens to be used when processing file. (optional)
     - parameter skipEmbeddingGeneration: (query) Flag to control whether or not embeddings should be generated and stored             when processing file. (optional, default to false)
     - parameter setPageAsBoundary: (query) Flag to control whether or not to set the a page&#39;s worth of content as the maximum             amount of content that can appear in a chunk. Only valid for PDFs. See description route description for             more information. (optional, default to false)
     - parameter embeddingModel: (query) Embedding model that will be used to embed file chunks. (optional)
     - parameter useOcr: (query) Whether or not to use OCR when processing files. Valid for PDFs, JPEGs, and PNGs. Useful for documents with             tables, images, and/or scanned text. (optional, default to false)
     - parameter generateSparseVectors: (query) Whether or not to generate sparse vectors for the file. This is *required* for the file to be a             candidate for hybrid search. (optional, default to false)
     - parameter prependFilenameToChunks: (query) Whether or not to prepend the file&#39;s name to chunks. (optional, default to false)
     - parameter maxItemsPerChunk: (query) Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
     - parameter parsePdfTablesWithOcr: (query) Whether to use rich table parsing when &#x60;use_ocr&#x60; is enabled. (optional, default to false)
     - parameter detectAudioLanguage: (query) Whether to automatically detect the language of the uploaded audio file. (optional, default to false)
     - parameter transcriptionService: (query) The transcription service to use for audio files. If no service is specified, &#39;deepgram&#39; will be used. (optional)
     - parameter includeSpeakerLabels: (query) Detect multiple speakers and label segments of speech by speaker for audio files. (optional, default to false)
     - parameter mediaType: (query) The media type of the file. If not provided, it will be inferred from the file extension. (optional)
     - parameter splitRows: (query) Whether to split tabular rows into chunks. Currently only valid for CSV, TSV, and XLSX files. (optional, default to false)
     - parameter enableColdStorage: (query) Enable cold storage for the file. If set to true, the file will be moved to cold storage after a certain period of inactivity. Default is false. (optional, default to false)
     - parameter hotStorageTimeToLive: (query) Time in seconds after which the file will be moved to cold storage. (optional)
     - parameter generateChunksOnly: (query) If this flag is enabled, the file will be chunked and stored with Carbon,             but no embeddings will be generated. This overrides the skip_embedding_generation flag. (optional, default to false)
     - parameter storeFileOnly: (query) If this flag is enabled, the file will be stored with Carbon, but no processing will be done. (optional, default to false)
     - returns: RequestBuilder<UserFile> This endpoint is used to directly upload local files to Carbon. The &#x60;POST&#x60; request should be a multipart form request. Note that the &#x60;set_page_as_boundary&#x60; query parameter is applicable only to PDFs for now. When this value is set, PDF chunks are at most one page long. Additional information can be retrieved for each chunk, however, namely the coordinates of the bounding box around the chunk (this can be used for things like text highlighting). Following is a description of all possible query parameters: - &#x60;chunk_size&#x60;: the chunk size (in tokens) applied when splitting the document - &#x60;chunk_overlap&#x60;: the chunk overlap (in tokens) applied when splitting the document - &#x60;skip_embedding_generation&#x60;: whether or not to skip the generation of chunks and embeddings - &#x60;set_page_as_boundary&#x60;: described above - &#x60;embedding_model&#x60;: the model used to generate embeddings for the document chunks - &#x60;use_ocr&#x60;: whether or not to use OCR as a preprocessing step prior to generating chunks. Valid for PDFs, JPEGs, and PNGs - &#x60;generate_sparse_vectors&#x60;: whether or not to generate sparse vectors for the file. Required for hybrid search. - &#x60;prepend_filename_to_chunks&#x60;: whether or not to prepend the filename to the chunk text   Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI&#39;s multimodal model; for text, we support OpenAI&#39;s &#x60;text-embedding-ada-002&#x60; and Cohere&#39;s embed-multilingual-v3.0. The model can be specified via the &#x60;embedding_model&#x60; parameter (in the POST body for &#x60;/embeddings&#x60;, and a query  parameter in &#x60;/uploadfile&#x60;). If no model is supplied, the &#x60;text-embedding-ada-002&#x60; is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with &#x60;OPENAI&#x60;, and files C and D have embeddings generated with &#x60;COHERE_MULTILINGUAL_V3&#x60;, then by default, queries will only consider files A and B. If &#x60;COHERE_MULTILINGUAL_V3&#x60; is specified as the &#x60;embedding_model&#x60; in &#x60;/embeddings&#x60;, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set &#x60;VERTEX_MULTIMODAL&#x60; as an &#x60;embedding_model&#x60;. This model is used automatically by Carbon when it detects an image file.
     */
    open func uploadWithRequestBuilder(
            file: URL,
            bodyCreateUploadFileUploadfilePost: BodyCreateUploadFileUploadfilePost,
            chunkSize: Int? = nil,
            chunkOverlap: Int? = nil,
            skipEmbeddingGeneration: Bool? = nil,
            setPageAsBoundary: Bool? = nil,
            embeddingModel: EmbeddingModel? = nil,
            useOcr: Bool? = nil,
            generateSparseVectors: Bool? = nil,
            prependFilenameToChunks: Bool? = nil,
            maxItemsPerChunk: Int? = nil,
            parsePdfTablesWithOcr: Bool? = nil,
            detectAudioLanguage: Bool? = nil,
            transcriptionService: TranscriptionServiceNullable? = nil,
            includeSpeakerLabels: Bool? = nil,
            mediaType: FileContentTypesNullable? = nil,
            splitRows: Bool? = nil,
            enableColdStorage: Bool? = nil,
            hotStorageTimeToLive: Int? = nil,
            generateChunksOnly: Bool? = nil,
            storeFileOnly: Bool? = nil
    ) -> RequestBuilder<UserFile> {
        let basePath = self.client!.basePath;
        let localVariablePath = "/uploadfile"
        let localVariableURLString = basePath + localVariablePath
        let localVariableFormParams: [String: Any?] = [
            "file": file.encodeToJSON(),
        ]

        let localVariableNonNullParameters = APIHelper.rejectNil(localVariableFormParams)
        let localVariableParameters = APIHelper.convertBoolToString(localVariableNonNullParameters)
        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "chunk_size": (wrappedValue: chunkSize?.encodeToJSON(), isExplode: true),
            "chunk_overlap": (wrappedValue: chunkOverlap?.encodeToJSON(), isExplode: true),
            "skip_embedding_generation": (wrappedValue: skipEmbeddingGeneration?.encodeToJSON(), isExplode: true),
            "set_page_as_boundary": (wrappedValue: setPageAsBoundary?.encodeToJSON(), isExplode: true),
            "embedding_model": (wrappedValue: embeddingModel?.encodeToJSON(), isExplode: true),
            "use_ocr": (wrappedValue: useOcr?.encodeToJSON(), isExplode: true),
            "generate_sparse_vectors": (wrappedValue: generateSparseVectors?.encodeToJSON(), isExplode: true),
            "prepend_filename_to_chunks": (wrappedValue: prependFilenameToChunks?.encodeToJSON(), isExplode: true),
            "max_items_per_chunk": (wrappedValue: maxItemsPerChunk?.encodeToJSON(), isExplode: true),
            "parse_pdf_tables_with_ocr": (wrappedValue: parsePdfTablesWithOcr?.encodeToJSON(), isExplode: true),
            "detect_audio_language": (wrappedValue: detectAudioLanguage?.encodeToJSON(), isExplode: true),
            "transcription_service": (wrappedValue: transcriptionService?.encodeToJSON(), isExplode: true),
            "include_speaker_labels": (wrappedValue: includeSpeakerLabels?.encodeToJSON(), isExplode: true),
            "media_type": (wrappedValue: mediaType?.encodeToJSON(), isExplode: true),
            "split_rows": (wrappedValue: splitRows?.encodeToJSON(), isExplode: true),
            "enable_cold_storage": (wrappedValue: enableColdStorage?.encodeToJSON(), isExplode: true),
            "hot_storage_time_to_live": (wrappedValue: hotStorageTimeToLive?.encodeToJSON(), isExplode: true),
            "generate_chunks_only": (wrappedValue: generateChunksOnly?.encodeToJSON(), isExplode: true),
            "store_file_only": (wrappedValue: storeFileOnly?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "multipart/form-data",
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client!.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /uploadfile")
    }


    /**
     Create Upload File From Url
     
     - parameter uploadFileFromUrlInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func uploadFromUrlSync(uploadFileFromUrlInput: UploadFileFromUrlInput, apiResponseQueue: DispatchQueue = CarbonAIAPI.apiResponseQueue, completion: @escaping ((_ data: UserFile?, _ error: Error?) -> Void)) -> RequestTask {
        return uploadFromUrlWithRequestBuilder(uploadFileFromUrlInput: uploadFileFromUrlInput).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Create Upload File From Url
     
     - parameter uploadFileFromUrlInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func uploadFromUrlAsyncMappedParams(uploadFileFromUrlInput: UploadFileFromUrlInput) async throws -> UserFile {
        return try await withCheckedThrowingContinuation { continuation in
            uploadFromUrlWithRequestBuilder(uploadFileFromUrlInput: uploadFileFromUrlInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Create Upload File From Url
     
     - parameter uploadFileFromUrlInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func uploadFromUrl(
        url: String,
        fileName: String? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        setPageAsBoundary: Bool? = nil, 
        embeddingModel: EmbeddingGenerators? = nil, 
        generateSparseVectors: Bool? = nil, 
        useTextract: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        maxItemsPerChunk: Int? = nil, 
        parsePdfTablesWithOcr: Bool? = nil, 
        detectAudioLanguage: Bool? = nil, 
        transcriptionService: TranscriptionServiceNullable? = nil, 
        includeSpeakerLabels: Bool? = nil, 
        mediaType: FileContentTypesNullable? = nil, 
        splitRows: Bool? = nil, 
        coldStorageParams: ColdStorageProps? = nil, 
        generateChunksOnly: Bool? = nil, 
        storeFileOnly: Bool? = nil
    ) async throws -> UserFile {
        let uploadFileFromUrlInput = UploadFileFromUrlInput(
            url: url,
            fileName: fileName,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            setPageAsBoundary: setPageAsBoundary,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            useTextract: useTextract,
            prependFilenameToChunks: prependFilenameToChunks,
            maxItemsPerChunk: maxItemsPerChunk,
            parsePdfTablesWithOcr: parsePdfTablesWithOcr,
            detectAudioLanguage: detectAudioLanguage,
            transcriptionService: transcriptionService,
            includeSpeakerLabels: includeSpeakerLabels,
            mediaType: mediaType,
            splitRows: splitRows,
            coldStorageParams: coldStorageParams,
            generateChunksOnly: generateChunksOnly,
            storeFileOnly: storeFileOnly
        )
        return try await withCheckedThrowingContinuation { continuation in
            uploadFromUrlWithRequestBuilder(uploadFileFromUrlInput: uploadFileFromUrlInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Create Upload File From Url
     
     - parameter uploadFileFromUrlInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func uploadFromUrl(
        url: String,
        fileName: String? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        setPageAsBoundary: Bool? = nil, 
        embeddingModel: EmbeddingGenerators? = nil, 
        generateSparseVectors: Bool? = nil, 
        useTextract: Bool? = nil, 
        prependFilenameToChunks: Bool? = nil, 
        maxItemsPerChunk: Int? = nil, 
        parsePdfTablesWithOcr: Bool? = nil, 
        detectAudioLanguage: Bool? = nil, 
        transcriptionService: TranscriptionServiceNullable? = nil, 
        includeSpeakerLabels: Bool? = nil, 
        mediaType: FileContentTypesNullable? = nil, 
        splitRows: Bool? = nil, 
        coldStorageParams: ColdStorageProps? = nil, 
        generateChunksOnly: Bool? = nil, 
        storeFileOnly: Bool? = nil
    ) async throws -> UserFile {
        let uploadFileFromUrlInput = UploadFileFromUrlInput(
            url: url,
            fileName: fileName,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            setPageAsBoundary: setPageAsBoundary,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            useTextract: useTextract,
            prependFilenameToChunks: prependFilenameToChunks,
            maxItemsPerChunk: maxItemsPerChunk,
            parsePdfTablesWithOcr: parsePdfTablesWithOcr,
            detectAudioLanguage: detectAudioLanguage,
            transcriptionService: transcriptionService,
            includeSpeakerLabels: includeSpeakerLabels,
            mediaType: mediaType,
            splitRows: splitRows,
            coldStorageParams: coldStorageParams,
            generateChunksOnly: generateChunksOnly,
            storeFileOnly: storeFileOnly
        )
        return try await withCheckedThrowingContinuation { continuation in
            uploadFromUrlWithRequestBuilder(uploadFileFromUrlInput: uploadFileFromUrlInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Create Upload File From Url
     - POST /upload_file_from_url
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter uploadFileFromUrlInput: (body)  
     - returns: RequestBuilder<UserFile> 
     */
    open class func uploadFromUrlWithRequestBuilder(
            uploadFileFromUrlInput: UploadFileFromUrlInput
    ) -> RequestBuilder<UserFile> {
        let basePath = CarbonAIAPI.basePath;
        let localVariablePath = "/upload_file_from_url"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: uploadFileFromUrlInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAIAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /upload_file_from_url")
    }

    /**
     Create Upload File From Url
     - POST /upload_file_from_url
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter uploadFileFromUrlInput: (body)  
     - returns: RequestBuilder<UserFile> 
     */
    open func uploadFromUrlWithRequestBuilder(
            uploadFileFromUrlInput: UploadFileFromUrlInput
    ) -> RequestBuilder<UserFile> {
        let basePath = self.client!.basePath;
        let localVariablePath = "/upload_file_from_url"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: uploadFileFromUrlInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client!.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /upload_file_from_url")
    }


    /**
     Create Raw Text
     
     - parameter rawTextInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func uploadTextSync(rawTextInput: RawTextInput, apiResponseQueue: DispatchQueue = CarbonAIAPI.apiResponseQueue, completion: @escaping ((_ data: UserFile?, _ error: Error?) -> Void)) -> RequestTask {
        return uploadTextWithRequestBuilder(rawTextInput: rawTextInput).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Create Raw Text
     
     - parameter rawTextInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    private class func uploadTextAsyncMappedParams(rawTextInput: RawTextInput) async throws -> UserFile {
        return try await withCheckedThrowingContinuation { continuation in
            uploadTextWithRequestBuilder(rawTextInput: rawTextInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /**
     Create Raw Text
     
     - parameter rawTextInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open class func uploadText(
        contents: String,
        name: String? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        overwriteFileId: Int? = nil, 
        embeddingModel: EmbeddingGeneratorsNullable? = nil, 
        generateSparseVectors: Bool? = nil, 
        coldStorageParams: ColdStorageProps? = nil, 
        generateChunksOnly: Bool? = nil, 
        storeFileOnly: Bool? = nil
    ) async throws -> UserFile {
        let rawTextInput = RawTextInput(
            contents: contents,
            name: name,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            overwriteFileId: overwriteFileId,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            coldStorageParams: coldStorageParams,
            generateChunksOnly: generateChunksOnly,
            storeFileOnly: storeFileOnly
        )
        return try await withCheckedThrowingContinuation { continuation in
            uploadTextWithRequestBuilder(rawTextInput: rawTextInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    /**
     Create Raw Text
     
     - parameter rawTextInput: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    open func uploadText(
        contents: String,
        name: String? = nil, 
        chunkSize: Int? = nil, 
        chunkOverlap: Int? = nil, 
        skipEmbeddingGeneration: Bool? = nil, 
        overwriteFileId: Int? = nil, 
        embeddingModel: EmbeddingGeneratorsNullable? = nil, 
        generateSparseVectors: Bool? = nil, 
        coldStorageParams: ColdStorageProps? = nil, 
        generateChunksOnly: Bool? = nil, 
        storeFileOnly: Bool? = nil
    ) async throws -> UserFile {
        let rawTextInput = RawTextInput(
            contents: contents,
            name: name,
            chunkSize: chunkSize,
            chunkOverlap: chunkOverlap,
            skipEmbeddingGeneration: skipEmbeddingGeneration,
            overwriteFileId: overwriteFileId,
            embeddingModel: embeddingModel,
            generateSparseVectors: generateSparseVectors,
            coldStorageParams: coldStorageParams,
            generateChunksOnly: generateChunksOnly,
            storeFileOnly: storeFileOnly
        )
        return try await withCheckedThrowingContinuation { continuation in
            uploadTextWithRequestBuilder(rawTextInput: rawTextInput).execute { result in
                switch result {
                case let .success(response):
                    continuation.resume(returning: response.body)
                case let .failure(error):
                    continuation.resume(throwing: error)
                }
            }
        }
    }



    /**
     Create Raw Text
     - POST /upload_text
     - Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI's multimodal model; for text, we support OpenAI's `text-embedding-ada-002` and Cohere's embed-multilingual-v3.0. The model can be specified via the `embedding_model` parameter (in the POST body for `/embeddings`, and a query  parameter in `/uploadfile`). If no model is supplied, the `text-embedding-ada-002` is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with `OPENAI`, and files C and D have embeddings generated with `COHERE_MULTILINGUAL_V3`, then by default, queries will only consider files A and B. If `COHERE_MULTILINGUAL_V3` is specified as the `embedding_model` in `/embeddings`, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set `VERTEX_MULTIMODAL` as an `embedding_model`. This model is used automatically by Carbon when it detects an image file.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter rawTextInput: (body)  
     - returns: RequestBuilder<UserFile> Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI&#39;s multimodal model; for text, we support OpenAI&#39;s &#x60;text-embedding-ada-002&#x60; and Cohere&#39;s embed-multilingual-v3.0. The model can be specified via the &#x60;embedding_model&#x60; parameter (in the POST body for &#x60;/embeddings&#x60;, and a query  parameter in &#x60;/uploadfile&#x60;). If no model is supplied, the &#x60;text-embedding-ada-002&#x60; is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with &#x60;OPENAI&#x60;, and files C and D have embeddings generated with &#x60;COHERE_MULTILINGUAL_V3&#x60;, then by default, queries will only consider files A and B. If &#x60;COHERE_MULTILINGUAL_V3&#x60; is specified as the &#x60;embedding_model&#x60; in &#x60;/embeddings&#x60;, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set &#x60;VERTEX_MULTIMODAL&#x60; as an &#x60;embedding_model&#x60;. This model is used automatically by Carbon when it detects an image file.
     */
    open class func uploadTextWithRequestBuilder(
            rawTextInput: RawTextInput
    ) -> RequestBuilder<UserFile> {
        let basePath = CarbonAIAPI.basePath;
        let localVariablePath = "/upload_text"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: rawTextInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: CarbonAIAPI.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: CarbonAIAPI.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /upload_text")
    }

    /**
     Create Raw Text
     - POST /upload_text
     - Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI's multimodal model; for text, we support OpenAI's `text-embedding-ada-002` and Cohere's embed-multilingual-v3.0. The model can be specified via the `embedding_model` parameter (in the POST body for `/embeddings`, and a query  parameter in `/uploadfile`). If no model is supplied, the `text-embedding-ada-002` is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with `OPENAI`, and files C and D have embeddings generated with `COHERE_MULTILINGUAL_V3`, then by default, queries will only consider files A and B. If `COHERE_MULTILINGUAL_V3` is specified as the `embedding_model` in `/embeddings`, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set `VERTEX_MULTIMODAL` as an `embedding_model`. This model is used automatically by Carbon when it detects an image file.
     - API Key:
       - type: apiKey authorization 
       - name: accessToken
     - API Key:
       - type: apiKey authorization 
       - name: apiKey
     - API Key:
       - type: apiKey customer-id 
       - name: customerId
     - parameter rawTextInput: (body)  
     - returns: RequestBuilder<UserFile> Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI&#39;s multimodal model; for text, we support OpenAI&#39;s &#x60;text-embedding-ada-002&#x60; and Cohere&#39;s embed-multilingual-v3.0. The model can be specified via the &#x60;embedding_model&#x60; parameter (in the POST body for &#x60;/embeddings&#x60;, and a query  parameter in &#x60;/uploadfile&#x60;). If no model is supplied, the &#x60;text-embedding-ada-002&#x60; is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with &#x60;OPENAI&#x60;, and files C and D have embeddings generated with &#x60;COHERE_MULTILINGUAL_V3&#x60;, then by default, queries will only consider files A and B. If &#x60;COHERE_MULTILINGUAL_V3&#x60; is specified as the &#x60;embedding_model&#x60; in &#x60;/embeddings&#x60;, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set &#x60;VERTEX_MULTIMODAL&#x60; as an &#x60;embedding_model&#x60;. This model is used automatically by Carbon when it detects an image file.
     */
    open func uploadTextWithRequestBuilder(
            rawTextInput: RawTextInput
    ) -> RequestBuilder<UserFile> {
        let basePath = self.client!.basePath;
        let localVariablePath = "/upload_text"
        let localVariableURLString = basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: rawTextInput)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        var localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        do {
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.accessToken, prefix: "Token ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "authorization", value: self.client!.apiKey, prefix: "Bearer ")
            try Authentication.setAuthenticationParameters(headers: &localVariableHeaderParameters, url: &localVariableUrlComponents, in: "header", name: "customer-id", value: self.client!.customerId, prefix: nil)
            let localVariableRequestBuilder: RequestBuilder<UserFile>.Type = CarbonAIAPI.requestBuilderFactory.getBuilder()
            let URLString = localVariableUrlComponents?.string ?? localVariableURLString
            return localVariableRequestBuilder.init(method: "POST", URLString: URLString, parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
        } catch {
            print("Error: \(error)")
        }
        fatalError("Error: Unable to send request to POST /upload_text")
    }

}
