//
// FileSyncConfig.swift
//
// Generated by Konfig
// https://konfigthis.com
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct FileSyncConfig: Codable, JSONEncodable, Hashable {

    /** File types to automatically sync when the data source connects. Only a subset of file types can be          controlled. If not supported, then they will always be synced */
    public var autoSyncedSourceTypes: [AutoSyncedSourceTypesPropertyInner]?
    /** Automatically sync attachments from files where supported. Currently applies to Helpdesk Tickets */
    public var syncAttachments: Bool? = false
    /** Detect audio language before transcription for audio files */
    public var detectAudioLanguage: Bool? = false
    public var transcriptionService: TranscriptionServiceNullable?
    /** Detect multiple speakers and label segments of speech by speaker for audio files. */
    public var includeSpeakerLabels: Bool? = false
    /** Whether to split tabular rows into chunks. Currently only valid for CSV, TSV, and XLSX files. */
    public var splitRows: Bool? = false
    /** If this flag is enabled, the file will be chunked and stored with Carbon,           but no embeddings will be generated. This overrides the skip_embedding_generation flag. */
    public var generateChunksOnly: Bool? = false
    /** Setting this flag will create a new file record with Carbon but skip any and all processing.          This means that we do not download the remote file content or generate any chunks or embeddings. We will store         some metadata like name, external id, and external URL depending on the source you are syncing from. Note that this          flag overrides both skip_embedding_generation and generate_chunks_only flags. The file will be moved to          READY_TO_SYNC status. */
    public var skipFileProcessing: Bool? = false

    public init(autoSyncedSourceTypes: [AutoSyncedSourceTypesPropertyInner]? = nil, syncAttachments: Bool? = false, detectAudioLanguage: Bool? = false, transcriptionService: TranscriptionServiceNullable? = nil, includeSpeakerLabels: Bool? = false, splitRows: Bool? = false, generateChunksOnly: Bool? = false, skipFileProcessing: Bool? = false) {
        self.autoSyncedSourceTypes = autoSyncedSourceTypes
        self.syncAttachments = syncAttachments
        self.detectAudioLanguage = detectAudioLanguage
        self.transcriptionService = transcriptionService
        self.includeSpeakerLabels = includeSpeakerLabels
        self.splitRows = splitRows
        self.generateChunksOnly = generateChunksOnly
        self.skipFileProcessing = skipFileProcessing
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case autoSyncedSourceTypes = "auto_synced_source_types"
        case syncAttachments = "sync_attachments"
        case detectAudioLanguage = "detect_audio_language"
        case transcriptionService = "transcription_service"
        case includeSpeakerLabels = "include_speaker_labels"
        case splitRows = "split_rows"
        case generateChunksOnly = "generate_chunks_only"
        case skipFileProcessing = "skip_file_processing"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var codingContainer = encoder.container(keyedBy: CodingKeys.self)
        try codingContainer.encodeIfPresent(autoSyncedSourceTypes, forKey: .autoSyncedSourceTypes)
        try codingContainer.encodeIfPresent(syncAttachments, forKey: .syncAttachments)
        try codingContainer.encodeIfPresent(detectAudioLanguage, forKey: .detectAudioLanguage)
        try codingContainer.encodeIfPresent(transcriptionService, forKey: .transcriptionService)
        try codingContainer.encodeIfPresent(includeSpeakerLabels, forKey: .includeSpeakerLabels)
        try codingContainer.encodeIfPresent(splitRows, forKey: .splitRows)
        try codingContainer.encodeIfPresent(generateChunksOnly, forKey: .generateChunksOnly)
        try codingContainer.encodeIfPresent(skipFileProcessing, forKey: .skipFileProcessing)
    }
}

