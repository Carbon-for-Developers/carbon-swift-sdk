//
// WebscrapeRequest.swift
//
// Generated by Konfig
// https://konfigthis.com
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct WebscrapeRequest: Codable, JSONEncodable, Hashable {

    public var tags: [String: Tags1]?
    public var url: String
    public var recursionDepth: Int? = 3
    public var maxPagesToScrape: Int? = 100
    public var chunkSize: Int? = 1500
    public var chunkOverlap: Int? = 20
    public var skipEmbeddingGeneration: Bool? = false
    public var enableAutoSync: Bool? = false
    public var generateSparseVectors: Bool? = false
    public var prependFilenameToChunks: Bool? = false
    public var htmlTagsToSkip: [String]?
    public var cssClassesToSkip: [String]?
    public var cssSelectorsToSkip: [String]?
    public var embeddingModel: EmbeddingGenerators?
    /** URL subpaths or directories that you want to include. For example if you want to only include         URLs that start with /questions in stackoverflow.com, you will add /questions/ in this input */
    public var urlPathsToInclude: [String]?
    /** Whether the scraper should download css and media from the page (images, fonts, etc). Scrapes          might take longer to finish with this flag enabled, but the success rate is improved. */
    public var downloadCssAndMedia: Bool? = false
    /** If this flag is enabled, the file will be chunked and stored with Carbon,           but no embeddings will be generated. This overrides the skip_embedding_generation flag. */
    public var generateChunksOnly: Bool? = false
    /** If this flag is enabled, the file will be stored with Carbon, but no processing will be done. */
    public var storeFileOnly: Bool? = false
    /** If the default proxies are blocked and not returning results, this flag can be enabled to use              alternate proxies (residential and office). Scrapes might take longer to finish with this flag enabled.          */
    public var usePremiumProxies: Bool? = false

    public init(tags: [String: Tags1]? = nil, url: String, recursionDepth: Int? = 3, maxPagesToScrape: Int? = 100, chunkSize: Int? = 1500, chunkOverlap: Int? = 20, skipEmbeddingGeneration: Bool? = false, enableAutoSync: Bool? = false, generateSparseVectors: Bool? = false, prependFilenameToChunks: Bool? = false, htmlTagsToSkip: [String]? = nil, cssClassesToSkip: [String]? = nil, cssSelectorsToSkip: [String]? = nil, embeddingModel: EmbeddingGenerators? = nil, urlPathsToInclude: [String]? = nil, downloadCssAndMedia: Bool? = false, generateChunksOnly: Bool? = false, storeFileOnly: Bool? = false, usePremiumProxies: Bool? = false) {
        self.tags = tags
        self.url = url
        self.recursionDepth = recursionDepth
        self.maxPagesToScrape = maxPagesToScrape
        self.chunkSize = chunkSize
        self.chunkOverlap = chunkOverlap
        self.skipEmbeddingGeneration = skipEmbeddingGeneration
        self.enableAutoSync = enableAutoSync
        self.generateSparseVectors = generateSparseVectors
        self.prependFilenameToChunks = prependFilenameToChunks
        self.htmlTagsToSkip = htmlTagsToSkip
        self.cssClassesToSkip = cssClassesToSkip
        self.cssSelectorsToSkip = cssSelectorsToSkip
        self.embeddingModel = embeddingModel
        self.urlPathsToInclude = urlPathsToInclude
        self.downloadCssAndMedia = downloadCssAndMedia
        self.generateChunksOnly = generateChunksOnly
        self.storeFileOnly = storeFileOnly
        self.usePremiumProxies = usePremiumProxies
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case tags
        case url
        case recursionDepth = "recursion_depth"
        case maxPagesToScrape = "max_pages_to_scrape"
        case chunkSize = "chunk_size"
        case chunkOverlap = "chunk_overlap"
        case skipEmbeddingGeneration = "skip_embedding_generation"
        case enableAutoSync = "enable_auto_sync"
        case generateSparseVectors = "generate_sparse_vectors"
        case prependFilenameToChunks = "prepend_filename_to_chunks"
        case htmlTagsToSkip = "html_tags_to_skip"
        case cssClassesToSkip = "css_classes_to_skip"
        case cssSelectorsToSkip = "css_selectors_to_skip"
        case embeddingModel = "embedding_model"
        case urlPathsToInclude = "url_paths_to_include"
        case downloadCssAndMedia = "download_css_and_media"
        case generateChunksOnly = "generate_chunks_only"
        case storeFileOnly = "store_file_only"
        case usePremiumProxies = "use_premium_proxies"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var codingContainer = encoder.container(keyedBy: CodingKeys.self)
        try codingContainer.encodeIfPresent(tags, forKey: .tags)
        try codingContainer.encode(url, forKey: .url)
        try codingContainer.encodeIfPresent(recursionDepth, forKey: .recursionDepth)
        try codingContainer.encodeIfPresent(maxPagesToScrape, forKey: .maxPagesToScrape)
        try codingContainer.encodeIfPresent(chunkSize, forKey: .chunkSize)
        try codingContainer.encodeIfPresent(chunkOverlap, forKey: .chunkOverlap)
        try codingContainer.encodeIfPresent(skipEmbeddingGeneration, forKey: .skipEmbeddingGeneration)
        try codingContainer.encodeIfPresent(enableAutoSync, forKey: .enableAutoSync)
        try codingContainer.encodeIfPresent(generateSparseVectors, forKey: .generateSparseVectors)
        try codingContainer.encodeIfPresent(prependFilenameToChunks, forKey: .prependFilenameToChunks)
        try codingContainer.encodeIfPresent(htmlTagsToSkip, forKey: .htmlTagsToSkip)
        try codingContainer.encodeIfPresent(cssClassesToSkip, forKey: .cssClassesToSkip)
        try codingContainer.encodeIfPresent(cssSelectorsToSkip, forKey: .cssSelectorsToSkip)
        try codingContainer.encodeIfPresent(embeddingModel, forKey: .embeddingModel)
        try codingContainer.encodeIfPresent(urlPathsToInclude, forKey: .urlPathsToInclude)
        try codingContainer.encodeIfPresent(downloadCssAndMedia, forKey: .downloadCssAndMedia)
        try codingContainer.encodeIfPresent(generateChunksOnly, forKey: .generateChunksOnly)
        try codingContainer.encodeIfPresent(storeFileOnly, forKey: .storeFileOnly)
        try codingContainer.encodeIfPresent(usePremiumProxies, forKey: .usePremiumProxies)
    }
}

